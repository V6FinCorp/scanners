<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trading Scanners Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial@0.2.1/dist/chartjs-chart-financial.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="simple-theme.css">
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="header-content">
            <div class="header-left">
                <h1 class="header-title"><i class="fas fa-chart-line"></i> Trading Scanners</h1>
                <div id="headerSummaryInfo" class="header-center" style="display: none;">
                    <div class="header-symbol-info">
                        <span id="headerSymbolName">--</span>
                        <span class="symbol-price" id="headerSymbolPrice">0.00</span>
                    </div>
                    <div class="last-updated">
                        <i class="fas fa-clock"></i> <span id="headerLastUpdated">Last Updated: --</span>
                    </div>
                </div>
            </div>
            <div class="header-actions">
                <div style="display: flex; align-items: center; gap: 1rem;">
                    <!-- Symbol Selector -->
                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                        <label style="color: var(--text-secondary); font-size: 0.85rem; white-space: nowrap;">Symbol:</label>
                        <select id="symbols" class="form-select" onchange="onSymbolChange()" style="min-width: 120px; padding: 0.25rem 0.5rem; font-size: 0.85rem;">
                            <option value="">Select Symbol...</option>
                        </select>
                    </div>
                    <button id="runAllAnalysisBtn" onclick="runAllAnalysisManually()" class="btn btn-primary" style="padding: 0.5rem 0.75rem; font-size: 0.85rem;">
                        <i class="fas fa-rocket"></i> Run Full Analysis
                    </button>
                    <div class="text-muted">
                        <i class="fas fa-calendar"></i> <span style="font-size: 0.8rem;" id="currentDateTime">Sep 7, 2025 12:00:00 PM</span>
                    </div>
                </div>
                <!-- Dark Mode Toggle -->
                <button id="darkModeToggle" class="theme-toggle" title="Toggle Theme">
                    <i class="fas fa-moon"></i>
                </button>
            </div>
        </div>
    </header>

    <!-- Sidebar Toggle Button -->
    <button id="sidebarToggle" class="sidebar-toggle" onclick="toggleSidebar()">
        <i class="fas fa-times"></i>
    </button>
    
    <div class="container">
        <div class="dashboard-layout">
            <!-- Sidebar -->
            <div id="sidebar" class="sidebar">
                <div class="sidebar-content">
                    <div class="sidebar-header">
                        <h2 class="sidebar-title">
                            <i class="fas fa-cog"></i> Scanner & Parameters
                        </h2>
                    </div>
                    
                    <div class="sidebar-form">
                        <div class="form-grid">
                            <!-- Scanner Type -->
                            <div class="form-group">
                                <label class="form-label">Scanner</label>
                                <select id="scannerType" class="form-select">
                                    <option value="rsi">RSI</option>
                                    <option value="ema">EMA</option>
                                    <option value="dma">DMA</option>
                                    <option value="macd">MACD</option>
                                    <option value="volume">VOLUME</option>
                                </select>
                            </div>

                            <!-- Base Timeframe -->
                            <div class="form-group">
                                <label class="form-label">Timeframe</label>
                                <select id="baseTimeframe" class="form-select">
                                    <option value="5mins">5min</option>
                                    <option value="15mins">15min</option>
                                    <option value="30mins">30min</option>
                                    <option value="1hour">1H</option>
                                    <option value="daily">Daily</option>
                                </select>
                            </div>

                            <!-- Days to List -->
                            <div class="form-group">
                                <label class="form-label">Days</label>
                                <input type="number" id="daysToList" value="" min="1" max="30" class="form-input">
                            </div>
                        </div>

                        <!-- Dynamic Parameters based on Scanner Type -->
                        <div id="dynamicParams">
                            <!-- RSI Parameters -->
                            <div id="rsiParams">
                                <div class="form-grid">
                                    <div class="form-group">
                                        <label class="form-label">RSI Periods</label>
                                        <input type="text" id="rsiPeriods" value="" placeholder="" class="form-input">
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">Max Days</label>
                                        <input type="number" id="rsiDaysFallback" value="" min="10" max="500" class="form-input">
                                    </div>
                                </div>
                                <div class="form-grid">
                                    <div class="form-group">
                                        <label class="form-label">Overbought Level</label>
                                        <input type="number" id="rsiOverbought" value="" min="50" max="90" step="1" class="form-input">
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">Oversold Level</label>
                                        <input type="number" id="rsiOversold" value="" min="10" max="50" step="1" class="form-input">
                                    </div>
                                </div>
                            </div>

                            <!-- EMA Parameters -->
                            <div id="emaParams" class="hidden">
                                <div class="form-grid">
                                    <div class="form-group">
                                        <label class="form-label">EMA Periods</label>
                                        <input type="text" id="emaPeriods" value="" placeholder="" class="form-input">
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">Max Days</label>
                                        <input type="number" id="emaDaysFallback" value="" min="10" max="500" class="form-input">
                                    </div>
                                </div>
                            </div>

                            <!-- DMA Parameters -->
                            <div id="dmaParams" class="hidden">
                                <div class="form-grid">
                                    <div class="form-group">
                                        <label class="form-label">DMA Periods</label>
                                        <input type="text" id="dmaPeriods" value="" placeholder="" class="form-input">
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">Max Days</label>
                                        <input type="number" id="dmaDaysFallback" value="" min="10" max="500" class="form-input">
                                    </div>
                                </div>
                            </div>

                            <!-- MACD Parameters -->
                            <div id="macdParams" class="hidden">
                                <div class="form-grid">
                                    <div class="form-group">
                                        <label class="form-label">Fast Length</label>
                                        <input type="number" id="macdFastLength" value="" min="1" max="50" class="form-input">
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">Slow Length</label>
                                        <input type="number" id="macdSlowLength" value="" min="1" max="100" class="form-input">
                                    </div>
                                </div>
                                <div class="form-grid">
                                    <div class="form-group">
                                        <label class="form-label">Signal Length</label>
                                        <input type="number" id="macdSignalLength" value="" min="1" max="50" class="form-input">
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">Max Days</label>
                                        <input type="number" id="macdDaysFallback" value="" min="10" max="500" class="form-input">
                                    </div>
                                </div>
                                <div class="form-grid">
                                    <div class="form-group">
                                        <label class="form-label">Oscillator MA</label>
                                        <select id="macdOscillatorMA" class="form-select">
                                            <option value="EMA">EMA</option>
                                            <option value="SMA">SMA</option>
                                        </select>
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">Signal MA</label>
                                        <select id="macdSignalMA" class="form-select">
                                            <option value="EMA">EMA</option>
                                            <option value="SMA">SMA</option>
                                        </select>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- VOLUME Parameters -->
                            <div id="volumeParams" class="hidden">
                                <div class="form-grid">
                                    <div class="form-group">
                                        <label class="form-label">Volume MA Window</label>
                                        <input type="number" id="volumeMaWindow" value="20" min="1" max="200" class="form-input">
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">Spike Multiplier</label>
                                        <input type="number" id="volumeMultiplier" value="2.0" min="0.1" step="0.1" class="form-input">
                                    </div>
                                </div>
                                <div class="form-grid">
                                    <div class="form-group">
                                        <label class="form-label">Min Volume</label>
                                        <input type="number" id="volumeMinVolume" value="100000" min="0" class="form-input">
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">Max Days</label>
                                        <input type="number" id="volumeDaysFallback" value="30" min="1" max="500" class="form-input">
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Universal Run Button -->
                        <div class="sidebar-actions">
                            <button onclick="runAllAnalysisManually()" id="runButton" class="btn btn-primary btn-block">
                                <i class="fas fa-rocket"></i> Run Full Analysis
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Main Content -->
            <div id="mainContent" class="main-content">
                <!-- Current Analysis Section -->
                <div id="analysisSection" class="analysis-panel">
                    <div class="analysis-header">
                        <h2 class="analysis-title">
                            <i class="fas fa-chart-pie"></i> Current Analysis & Trading Signals
                        </h2>
                    </div>
                    
                    <div class="analysis-content">
                        <div id="analysisMessage" class="text-center text-muted" style="padding: 2rem;">
                            No current analysis available. Please run a scanner first to see trading signals.
                        </div>
                        <div id="analysisDisplay" class="hidden">
                            <!-- Current analysis will be dynamically generated here -->
                        </div>
                    </div>
                </div>

                <!-- Results Section with Tabs -->
                <div id="resultsSection" class="panel hidden">
                    <div class="panel-header">
                        <h2 class="panel-title">
                            <i class="fas fa-chart-area"></i> Scanner Results
                        </h2>
                        <div style="display: flex; gap: 0.5rem;">
                            <button onclick="exportResults()" class="btn btn-secondary btn-sm">
                                <i class="fas fa-save"></i> CSV
                            </button>
                            <button onclick="clearAllResults()" class="btn btn-secondary btn-sm">
                                <i class="fas fa-trash"></i> Clear All
                            </button>
                        </div>
                    </div>            <div class="panel-content">

            <!-- Scanner Tabs -->
            <div class="tabs mb-3">
                <nav class="tab-nav">
                    <button id="rsiScannerTab" onclick="switchScannerTab('rsi')" class="tab-button active">
                        <i class="fas fa-water"></i> RSI
                    </button>
                    <button id="emaScannerTab" onclick="switchScannerTab('ema')" class="tab-button">
                        <i class="fas fa-chart-line"></i> EMA
                    </button>
                    <button id="dmaScannerTab" onclick="switchScannerTab('dma')" class="tab-button">
                        <i class="fas fa-chart-bar"></i> DMA
                    </button>
                    <button id="macdScannerTab" onclick="switchScannerTab('macd')" class="tab-button">
                        <i class="fas fa-wave-square"></i> MACD
                    </button>
                    <button id="volumeScannerTab" onclick="switchScannerTab('volume')" class="tab-button">
                        <i class="fas fa-chart-area"></i> VOLUME
                    </button>
                </nav>
            </div>

            <!-- Content Tabs (Summary/Table/Chart/Results) -->
                    <div class="tabs mb-3">
                <nav class="tab-nav">
                        <button id="tableTab" onclick="switchContentTab('table')" class="tab-button active">
                        <i class="fas fa-table"></i> Table
                    </button>
                        <button id="chartTab" onclick="switchContentTab('chart')" class="tab-button">
                        <i class="fas fa-chart-line"></i> Price Chart
                    </button>
                    <button id="resultsTab" onclick="switchContentTab('results')" class="tab-button">
                        <i class="fas fa-chart-bar"></i> Results
                    </button>
                </nav>
            </div>

            <!-- Loading Indicator -->
            <div id="loadingIndicator" class="hidden text-center mb-4">
                <div class="loading" style="display: inline-block; margin-right: 0.5rem;"></div>
                <span>Running scanner...</span>
            </div>

            <!-- Results Tab Content -->
            <div id="resultsTabContent">
                <div id="resultsDisplay">
                    <pre id="resultsOutput" style="background-color: var(--bg-primary); padding: 1rem; border-radius: 4px; overflow-x: auto; white-space: pre-wrap; font-size: 0.8rem; min-height: 200px;"></pre>
                </div>
            </div>

            <!-- Table Tab Content -->
            <div id="tableTabContent">
                <div class="mb-3" style="display: flex; justify-content: space-between; align-items: center;">
                    <h3 class="panel-title">Detail View</h3>
                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                        <label class="form-label">Rows to show:</label>
                        <select id="tableRowsSelect" onchange="updateTableDisplay()" class="form-select">
                            <option value="10">10</option>
                            <option value="25">25</option>
                            <option value="50" selected>50</option>
                            <option value="all">All</option>
                        </select>
                    </div>
                </div>
                <div id="tableContainer" class="table-container">
                    <table id="resultsTable" class="table">
                        <thead>
                            <tr id="tableHeaderRow">
                                <th id="timeHeader" class="sortable">
                                    Time <span id="timeSortIcon">↓</span>
                                </th>
                                <th class="non-sortable">
                                    Symbol <span></span>
                                </th>
                                <th class="non-sortable">
                                    CMP <span></span>
                                </th>
                                <!-- Dynamic indicator headers will be inserted here -->
                            </tr>
                        </thead>
                        <tbody id="tableBody">
                            <!-- Table rows will be dynamically generated -->
                        </tbody>
                    </table>
                    <div id="tableMessage" class="text-center text-muted" style="padding: 2rem;">
                        No data available. Please run a scanner first.
                    </div>
                </div>
            </div>

            <!-- Chart Tab Content -->
            <div id="chartTabContent" class="hidden">
                <div class="mb-3" style="display: flex; justify-content: space-between; align-items: center;">
                    <h3 class="panel-title">Price Chart</h3>
                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                        <label class="form-label">Chart Type:</label>
                        <select id="chartTypeSelect" onchange="changeChartType()" class="form-select">
                            <option value="line">Line Chart</option>
                            <option value="candlestick">Candlestick (Colored Points)</option>
                        </select>
                        <button id="macdPreviewBtn" class="btn btn-secondary" style="margin-left:8px; display:none;" onclick="macdPreview()">Preview</button>
                        <button id="volumePreviewBtn" class="btn btn-secondary" style="margin-left:8px; display:none;" onclick="volumePreview()">Preview</button>
                    </div>
                </div>
                <div id="chartContainer">
                    <div class="chart-container">
                        <canvas id="priceChart" width="400" height="250"></canvas>
                    </div>
                </div>
            </div>
        </div>
        </div>

        <!-- Status Messages -->
            <div id="statusMessage" class="hidden">
            <div id="statusMessageInner" class="alert alert-info">
                <div style="display: flex; align-items: center; gap: 0.5rem;">
                    <span><i class="fas fa-info-circle"></i></span>
                    <div>
                        <h3 style="margin: 0; font-size: 0.9rem; font-weight: 600;">Status</h3>
                        <p id="statusText" style="margin: 0;"></p>
                    </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let currentScanner = 'rsi';
        let scannerResults = {
            rsi: null,
            ema: null,
            dma: null,
            macd: null,
            volume: null
        };
        let scannerOutputs = {
            rsi: '',
            ema: '',
            dma: '',
            macd: '',
            volume: ''
        };
        let scannerChartData = {
            rsi: null,
            ema: null,
            dma: null,
            macd: null,
            volume: null
        };
        let chart = null;
        let isDarkMode = false;
        let availableSymbols = [];
        let currentChartType = 'line'; // Default chart type
        let currentSortColumn = 'Time';
        let currentSortDirection = 'desc'; // Default to descending for time
        let isSidebarCollapsed = false; // Track sidebar state
        
        // Runtime config cache - stores last used values for each scanner type
        let runtimeConfig = {
            'rsi': {},
            'ema': {},  
            'dma': {},
            'macd': {},
            'volume': {}
        };
        
        // Flag to track if we should use runtime config or base config
        let useRuntimeConfig = false;

        // Sidebar toggle functionality
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const mainContent = document.getElementById('mainContent');
            const toggleButton = document.getElementById('sidebarToggle');
            const toggleIcon = toggleButton.querySelector('i');
            
            isSidebarCollapsed = !isSidebarCollapsed;
            
            if (isSidebarCollapsed) {
                sidebar.classList.add('collapsed');
                mainContent.classList.add('expanded');
                toggleButton.classList.add('active');
                toggleIcon.classList.remove('fa-times');
                toggleIcon.classList.add('fa-bars');
            } else {
                sidebar.classList.remove('collapsed');
                mainContent.classList.remove('expanded');
                toggleButton.classList.remove('active');
                toggleIcon.classList.remove('fa-bars');
                toggleIcon.classList.add('fa-times');
            }
        }

        // Defensive: watch for external modifications to the chart type select
        (function watchChartTypeSelect() {
            const select = document.getElementById('chartTypeSelect');
            if (!select) return;
            const observer = new MutationObserver(() => {
                // Re-apply allowed options for the current scanner to prevent stray inserts
                const scannerType = window.currentScanner || document.getElementById('scannerSelect')?.value;
                if (scannerType) updateChartTypeOptions(scannerType);
            });
            observer.observe(select, { childList: true, subtree: false, attributes: true });
        })();

        // Try to render MACD with a few retries to handle timing races between
        // results arriving and UI updates.
        function renderMacdWithRetry(retries, delayMs) {
            let attempts = 0;
            function attempt() {
                attempts++;
                ensureMacdChartDataAvailable();
                if (window.scannerChartData && scannerChartData.macd) {
                    try {
                        createChart(scannerChartData.macd, 'macd');
                        return; // success
                    } catch (err) {
                        console.warn('MACD render attempt failed:', err);
                    }
                }
                if (attempts < retries) {
                    setTimeout(attempt, delayMs);
                } else {
                    // final attempt failed; leave it gracefully — chart can be rendered manually
                    console.info('MACD render: no data after retries');
                }
            }
            attempt();
        }

        // Preview helper removed in production; charts now auto-render when data is available
        
        // Update header summary information
        function updateHeaderSummary(analyses) {
            const headerSummaryInfo = document.getElementById('headerSummaryInfo');
            const headerSymbolName = document.getElementById('headerSymbolName');
            const headerSymbolPrice = document.getElementById('headerSymbolPrice');
            const headerLastUpdated = document.getElementById('headerLastUpdated');
            
            if (analyses && Object.keys(analyses).length > 0) {
                const mainAnalysis = analyses.rsi || analyses.ema || analyses.dma || analyses.macd;
                if (mainAnalysis) {
                    const symbol = mainAnalysis['Symbol'] || '--';
                    const price = mainAnalysis['CMP'] || '0';
                    const time = mainAnalysis['Time'] || '--';
                    // Use base timeframe to decide if we should show time-of-day
                    const tf = document.getElementById('baseTimeframe') ? document.getElementById('baseTimeframe').value : 'daily';
                    const formatted = formatTimeForDisplay(time, tf);

                    headerSymbolName.textContent = symbol;
                    headerSymbolPrice.textContent = `₹${price}`;
                    headerLastUpdated.textContent = `Last Updated: ${formatted}`;
                    
                    headerSummaryInfo.style.display = 'flex';
                }
            } else {
                headerSummaryInfo.style.display = 'none';
            }
        }

        // Initialize
            document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, initializing dashboard...');
            console.log('Chart.js available:', typeof Chart !== 'undefined');
            console.log('Financial chart available:', typeof Chart && Chart.controllers && Chart.controllers.candlestick);
            
            setupEventListeners();
            showScannerParams('rsi');
            loadDarkModePreference();
            
            // Load config and auto-run scanner with defaults
            initializeDashboard();
            
            // Initialize chart type selector
            // Ensure chart type options reflect initial scanner
            updateChartTypeOptions(currentScanner);
            
            // Initialize scanner section as expanded
            const scannerContent = document.getElementById('scannerContent');
            // Content is visible by default

            // Start updating date/time
            updateDateTime();
            setInterval(updateDateTime, 1000); // Update every second
        });

        // Setup event listeners
        function setupEventListeners() {
            document.getElementById('scannerType').addEventListener('change', function(e) {
                currentScanner = e.target.value;
                showScannerParams(currentScanner);
                loadConfigForScanner(currentScanner);
            });

            // Dark mode toggle
            document.getElementById('darkModeToggle').addEventListener('click', toggleDarkMode);
        }

        // Update chart type dropdown and preview button based on scanner
        function updateChartTypeOptions(scannerType) {
            const chartTypeSelect = document.getElementById('chartTypeSelect');
            const previewBtn = document.getElementById('macdPreviewBtn');
            if (!chartTypeSelect) return;
            // Clear existing options
            chartTypeSelect.innerHTML = '';

            if (scannerType === 'macd') {
                const opt = document.createElement('option');
                opt.value = 'macd';
                opt.text = 'MACD Histogram + Lines';
                chartTypeSelect.appendChild(opt);
                chartTypeSelect.value = 'macd';
                if (previewBtn) previewBtn.style.display = '';
                const volPreview = document.getElementById('volumePreviewBtn'); if (volPreview) volPreview.style.display = 'none';
            } else if (scannerType === 'volume') {
                // Volume should only render as bar chart
                const o = document.createElement('option'); o.value = 'bar'; o.text = 'Volume (Bar)';
                chartTypeSelect.appendChild(o);
                chartTypeSelect.value = 'bar';
                if (previewBtn) previewBtn.style.display = 'none';
                const volPreview = document.getElementById('volumePreviewBtn'); if (volPreview) volPreview.style.display = '';
            } else {
                const o1 = document.createElement('option'); o1.value='line'; o1.text='Line Chart';
                const o2 = document.createElement('option'); o2.value='candlestick'; o2.text='Candlestick (Colored Points)';
                chartTypeSelect.appendChild(o1);
                chartTypeSelect.appendChild(o2);
                chartTypeSelect.value = 'line';
                if (previewBtn) previewBtn.style.display = 'none';
                const volPreview = document.getElementById('volumePreviewBtn'); if (volPreview) volPreview.style.display = 'none';
            }
        }

        // Populate and render a demo volume chart for quick preview (useful when no real data is available)
        function volumePreview() {
            // simple synthetic series: 60 points at 5-minute intervals
            const now = new Date();
            const labels = [];
            const volumes = [];
            const avgs = [];
            for (let i = 59; i >= 0; i--) {
                const dt = new Date(now.getTime() - i * 5 * 60 * 1000);
                const label = dt.getHours().toString().padStart(2,'0') + ':' + dt.getMinutes().toString().padStart(2,'0');
                labels.push(label);
                const base = 100000 + Math.round(Math.sin(i/5)*20000) + Math.round(Math.random()*30000);
                volumes.push(base);
                avgs.push(100000 + Math.round(Math.cos(i/10)*15000));
            }

            scannerChartData.volume = { labels: labels, volumes: volumes, avgVolumes: avgs };

            // Render main bar chart and small analysis chart
            try {
                createVolumeBarChart(scannerChartData.volume);
            } catch (err) {
                console.warn('volumePreview createVolumeBarChart failed', err);
            }

            try {
                renderVolumeAnalysisChart(scannerChartData.volume);
            } catch (err) {
                console.warn('volumePreview renderVolumeAnalysisChart failed', err);
            }
        }

        // Initialize dashboard with config loading and auto-run
        async function initializeDashboard() {
            console.log('Initializing dashboard with config defaults...');
            
            try {
                // Load symbols first
                await loadSymbolsFromConfig();
                
                // Load all indicator defaults
                await loadIndicatorDefaults();
                
                // Longer delay to ensure form is fully populated
                setTimeout(async () => {
                    console.log('Auto-running all scanners with config defaults...');
                    console.log('Current symbol value:', document.getElementById('symbols').value);
                    
                    // Check if symbol is selected
                    const selectedSymbol = document.getElementById('symbols').value;
                    if (!selectedSymbol || selectedSymbol.trim() === '') {
                        console.warn('No symbol selected, skipping auto-run');
                        return;
                    }
                    
                    // Run all four scanners sequentially with delays
                    const scanners = ['rsi', 'ema', 'dma', 'macd', 'volume'];
                    const originalScanner = currentScanner;
                    
                    for (let i = 0; i < scanners.length; i++) {
                        const scanner = scanners[i];
                        console.log(`Auto-running ${scanner.toUpperCase()} scanner...`);
                        
                        // Switch to scanner and load its config
                        currentScanner = scanner;
                        showScannerParams(scanner);
                        await loadConfigForScanner(scanner);
                        
                        // Run the scanner
                        await runScanner();
                        
                        // Add delay between scanners (except for the last one)
                        if (i < scanners.length - 1) {
                            console.log('Waiting 3 seconds before next scanner...');
                            await new Promise(resolve => setTimeout(resolve, 3000));
                        }
                    }
                    
                    // Reset to RSI scanner as default view
                    currentScanner = 'rsi';
                    showScannerParams('rsi');
                    displayScannerResults('rsi');
                    
                    console.log('All scanners auto-run completed!');
                    
                }, 2000);
                
            } catch (error) {
                console.error('Error initializing dashboard:', error);
            }
        }

        // Load symbols from config file and populate dropdown
        async function loadSymbolsFromConfig() {
            console.log('Loading symbols from config...');
            try {
                const response = await fetch('/api/config/symbols');
                console.log('Symbols config response status:', response.status);
                if (response.ok) {
                    const data = await response.json();
                    console.log('Symbols config data:', data);
                    availableSymbols = data.symbols || [];
                    populateSymbolDropdown();
                    
                    // Set first symbol as default selection
                    if (availableSymbols.length > 0) {
                        document.getElementById('symbols').value = availableSymbols[0];
                        console.log('Set default symbol to:', availableSymbols[0]);
                    }
                } else {
                    console.warn('Could not load symbols from config, status:', response.status);
                    availableSymbols = ['RELIANCE', 'TCS', 'HDFCBANK', 'ICICIBANK', 'INFY', 'ITC'];
                    populateSymbolDropdown();
                    document.getElementById('symbols').value = availableSymbols[0];
                }
            } catch (error) {
                console.error('Error loading symbols from config:', error);
                availableSymbols = ['RELIANCE', 'TCS', 'HDFCBANK', 'ICICIBANK', 'INFY', 'ITC'];
                populateSymbolDropdown();
                document.getElementById('symbols').value = availableSymbols[0];
            }
        }

        // Populate symbol dropdown with available symbols
        function populateSymbolDropdown() {
            const symbolSelect = document.getElementById('symbols');
            
            // Clear existing options except the first placeholder option
            symbolSelect.innerHTML = '<option value="">Select Symbol...</option>';
            
            // Add symbol options
            availableSymbols.forEach(symbol => {
                const option = document.createElement('option');
                option.value = symbol;
                option.textContent = symbol;
                symbolSelect.appendChild(option);
            });
        }

        // Show scanner-specific parameters
        function showScannerParams(scannerType) {
            // Hide all parameter sections
            document.getElementById('rsiParams').classList.add('hidden');
            document.getElementById('emaParams').classList.add('hidden');
            document.getElementById('dmaParams').classList.add('hidden');
            document.getElementById('macdParams').classList.add('hidden');

            // Show selected scanner parameters
            document.getElementById(scannerType + 'Params').classList.remove('hidden');
        }

        // Load indicator defaults from config files
        async function loadIndicatorDefaults() {
            console.log('Loading indicator defaults from config files...');
            
            // Load RSI defaults
            try {
                console.log('Fetching RSI config...');
                const rsiResponse = await fetch('/api/config/rsi');
                console.log('RSI config response status:', rsiResponse.status);
                if (rsiResponse.ok) {
                    const rsiConfig = await rsiResponse.json();
                    console.log('RSI config data:', rsiConfig);
                    
                    document.getElementById('rsiPeriods').value = (rsiConfig.rsi_periods || []).join(',');
                    document.getElementById('rsiDaysFallback').value = rsiConfig.days_fallback_threshold || '';
                    document.getElementById('rsiOverbought').value = rsiConfig.rsi_overbought || 70;
                    document.getElementById('rsiOversold').value = rsiConfig.rsi_oversold || 30;
                    
                    // Set base timeframe and days from RSI config
                    if (rsiConfig.base_timeframe) {
                        document.getElementById('baseTimeframe').value = rsiConfig.base_timeframe;
                        console.log('Set timeframe to:', rsiConfig.base_timeframe);
                    }
                    if (rsiConfig.days_to_list) {
                        document.getElementById('daysToList').value = rsiConfig.days_to_list;
                        console.log('Set days to list to:', rsiConfig.days_to_list);
                    }
                    
                    console.log('RSI config loaded successfully');
                } else {
                    console.warn('Failed to load RSI config, status:', rsiResponse.status);
                }
            } catch (error) {
                console.error('Error loading RSI config:', error);
            }

            // Load EMA defaults
            try {
                console.log('Fetching EMA config...');
                const emaResponse = await fetch('/api/config/ema');
                console.log('EMA config response status:', emaResponse.status);
                if (emaResponse.ok) {
                    const emaConfig = await emaResponse.json();
                    console.log('EMA config data:', emaConfig);
                    
                    document.getElementById('emaPeriods').value = (emaConfig.ema_periods || []).join(',');
                    document.getElementById('emaDaysFallback').value = emaConfig.days_fallback_threshold || '';
                    
                    console.log('EMA config loaded successfully');
                } else {
                    console.warn('Failed to load EMA config, status:', emaResponse.status);
                }
            } catch (error) {
                console.error('Error loading EMA config:', error);
            }

            // Load DMA defaults
            try {
                console.log('Fetching DMA config...');
                const dmaResponse = await fetch('/api/config/dma');
                console.log('DMA config response status:', dmaResponse.status);
                if (dmaResponse.ok) {
                    const dmaConfig = await dmaResponse.json();
                    console.log('DMA config data:', dmaConfig);
                    
                    document.getElementById('dmaPeriods').value = (dmaConfig.dma_periods || []).join(',');
                    document.getElementById('dmaDaysFallback').value = dmaConfig.days_fallback_threshold || '';
                    
                    console.log('DMA config loaded successfully');
                } else {
                    console.warn('Failed to load DMA config, status:', dmaResponse.status);
                }
            } catch (error) {
                console.error('Error loading DMA config:', error);
            }

            // Load MACD defaults
            try {
                console.log('Fetching MACD config...');
                const macdResponse = await fetch('/api/config/macd');
                console.log('MACD config response status:', macdResponse.status);
                if (macdResponse.ok) {
                    const macdConfig = await macdResponse.json();
                    console.log('MACD config data:', macdConfig);
                    
                    document.getElementById('macdFastLength').value = macdConfig.fast_length || 12;
                    document.getElementById('macdSlowLength').value = macdConfig.slow_length || 26;
                    document.getElementById('macdSignalLength').value = macdConfig.signal_length || 9;
                    document.getElementById('macdOscillatorMA').value = macdConfig.oscillator_ma_type || 'EMA';
                    document.getElementById('macdSignalMA').value = macdConfig.signal_ma_type || 'EMA';
                    document.getElementById('macdDaysFallback').value = macdConfig.days_fallback_threshold || '';
                    
                    console.log('MACD config loaded successfully');
                } else {
                    console.warn('Failed to load MACD config, status:', macdResponse.status);
                }
            } catch (error) {
                console.error('Error loading MACD config:', error);
            }
            
            console.log('Indicator defaults loading completed');
        }

        // Load config for specific scanner when scanner type changes
        async function loadConfigForScanner(scannerType) {
            console.log(`Loading config for ${scannerType} scanner...`);
            
            try {
                const response = await fetch(`/api/config/${scannerType}`);
                if (response.ok) {
                    const config = await response.json();
                    console.log(`${scannerType} config:`, config);
                    
                    // Load timeframe and days from the specific scanner config
                    if (config.base_timeframe) {
                        document.getElementById('baseTimeframe').value = config.base_timeframe;
                    }
                    if (config.days_to_list) {
                        document.getElementById('daysToList').value = config.days_to_list;
                    }
                    
                    // Load scanner-specific parameters
                    if (scannerType === 'rsi') {
                        if (config.rsi_periods) {
                            document.getElementById('rsiPeriods').value = config.rsi_periods.join(',');
                        }
                        if (config.days_fallback_threshold) {
                            document.getElementById('rsiDaysFallback').value = config.days_fallback_threshold;
                        }
                        if (config.rsi_overbought) {
                            document.getElementById('rsiOverbought').value = config.rsi_overbought;
                        }
                        if (config.rsi_oversold) {
                            document.getElementById('rsiOversold').value = config.rsi_oversold;
                        }
                    } else if (scannerType === 'ema') {
                        if (config.ema_periods) {
                            document.getElementById('emaPeriods').value = config.ema_periods.join(',');
                        }
                        if (config.days_fallback_threshold) {
                            document.getElementById('emaDaysFallback').value = config.days_fallback_threshold;
                        }
                    } else if (scannerType === 'dma') {
                        if (config.dma_periods) {
                            document.getElementById('dmaPeriods').value = config.dma_periods.join(',');
                        }
                        if (config.days_fallback_threshold) {
                            document.getElementById('dmaDaysFallback').value = config.days_fallback_threshold;
                        }
                    } else if (scannerType === 'macd') {
                        if (config.fast_length) {
                            document.getElementById('macdFastLength').value = config.fast_length;
                        }
                        if (config.slow_length) {
                            document.getElementById('macdSlowLength').value = config.slow_length;
                        }
                        if (config.signal_length) {
                            document.getElementById('macdSignalLength').value = config.signal_length;
                        }
                        if (config.oscillator_ma_type) {
                            document.getElementById('macdOscillatorMA').value = config.oscillator_ma_type;
                        }
                        if (config.signal_ma_type) {
                            document.getElementById('macdSignalMA').value = config.signal_ma_type;
                        }
                        if (config.days_fallback_threshold) {
                            document.getElementById('macdDaysFallback').value = config.days_fallback_threshold;
                        }
                    }
                    
                    console.log(`${scannerType} config loaded successfully`);
                }
            } catch (error) {
                console.error(`Error loading ${scannerType} config:`, error);
            }
        }

        // Dark mode functionality
        function toggleDarkMode() {
            isDarkMode = !isDarkMode;
            const toggleBtn = document.getElementById('darkModeToggle');

            if (isDarkMode) {
                document.documentElement.setAttribute('data-theme', 'dark');
                toggleBtn.innerHTML = '<i class="fas fa-sun"></i>'; // Sun emoji
                localStorage.setItem('darkMode', 'true');
            } else {
                document.documentElement.removeAttribute('data-theme');
                toggleBtn.innerHTML = '<i class="fas fa-moon"></i>'; // Moon emoji
                localStorage.setItem('darkMode', 'false');
            }
        }

        function loadDarkModePreference() {
            const saved = localStorage.getItem('darkMode');
            const toggleBtn = document.getElementById('darkModeToggle');

            if (saved === 'true') {
                isDarkMode = true;
                document.documentElement.setAttribute('data-theme', 'dark');
                toggleBtn.innerHTML = '<i class="fas fa-sun"></i>'; // Sun emoji
            } else {
                isDarkMode = false;
                document.documentElement.removeAttribute('data-theme');
                toggleBtn.innerHTML = '<i class="fas fa-moon"></i>'; // Moon emoji
            }
        }

        // Handle symbol change and auto-submit with enhanced loading states
        async function onSymbolChange() {
            const selectedSymbol = document.getElementById('symbols').value;
            console.log('Symbol changed to:', selectedSymbol);
            
            const analysisDisplay = document.getElementById('analysisDisplay');
            
            if (!selectedSymbol || selectedSymbol.trim() === '') {
                console.warn('No symbol selected, clearing analysis');
                if (analysisDisplay) {
                    analysisDisplay.innerHTML = '<div class="text-center text-muted p-4">Please select a symbol to view analysis</div>';
                }
                return;
            }
            
            // Show loading state immediately
            showAnalysisLoadingState(selectedSymbol);
            
            console.log('Auto-running all scanners with new symbol:', selectedSymbol);
            
            try {
                // Run all three scanners with progress updates
                await runAllScanners(selectedSymbol, true);
                console.log('Auto-run completed for all scanners');
            } catch (error) {
                console.error('Error during auto-run:', error);
                if (analysisDisplay) {
                    analysisDisplay.innerHTML = '<div class="text-center text-danger p-4">' +
                        '<i class="fas fa-exclamation-triangle"></i>' +
                        '<div>Error loading analysis for ' + selectedSymbol + '</div>' +
                        '<small>Please try again or check the server logs</small>' +
                    '</div>';
                }
            }
        }

        // Show interactive loading state for analysis
        function showAnalysisLoadingState(symbol) {
            const analysisDisplay = document.getElementById('analysisDisplay');
            if (!analysisDisplay) return;
            
            analysisDisplay.innerHTML = `
                <div class="analysis-loading-container">
                    <div class="analysis-header-card">
                        <div class="summary-card">
                            <div class="card-header">
                                <h3 class="card-title">
                                    <i class="fas fa-chart-line"></i> ' + symbol.toUpperCase() + ' Analysis
                                </h3>
                                <div class="text-muted">
                                    <i class="fas fa-sync fa-spin"></i> Loading complete analysis...
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="analysis-grid">
                        <!-- Final Recommendation Loading -->
                        <div class="analysis-row-recommendation">
                            <div class="analysis-card loading-card">
                                <div class="card-header">
                                    <h4><i class="fas fa-bullseye"></i> Final Recommendation</h4>
                                    <div class="loading-spinner"><i class="fas fa-spinner fa-spin"></i> Processing...</div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Row 2: Chart (Full Width) -->
                        <div class="analysis-row-recommendation">
                            <div class="analysis-card loading-card">
                                <div class="card-header">
                                    <h4><i class="fas fa-chart-area"></i> Price Chart</h4>
                                    <div class="loading-spinner"><i class="fas fa-spinner fa-spin"></i> Loading chart data...</div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Volume Chart Card (Full Width) -->
                        <div class="analysis-row-recommendation">
                            <div class="analysis-card loading-card">
                                <div class="card-header">
                                    <h4><i class="fas fa-chart-area"></i> Volume Chart</h4>
                                    <div class="loading-spinner"><i class="fas fa-spinner fa-spin"></i> Loading volume data...</div>
                                </div>
                                <div class="card-body" style="padding: 1rem;">
                                    <div class="chart-container">
                                        <canvas id="analysisVolumeChart" width="400" height="120"></canvas>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Row 3: RSI + MACD -->
                        <div class="analysis-row-1">
                            <div class="analysis-card loading-card">
                                <div class="card-header">
                                    <h4><i class="fas fa-chart-line"></i> RSI Analysis</h4>
                                    <div class="loading-spinner"><i class="fas fa-spinner fa-spin"></i> Calculating RSI...</div>
                                </div>
                            </div>
                            <div class="analysis-card loading-card">
                                <div class="card-header">
                                    <h4><i class="fas fa-wave-square"></i> MACD Analysis</h4>
                                    <div class="loading-spinner"><i class="fas fa-spinner fa-spin"></i> Calculating MACD...</div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Row 4: EMA + DMA -->
                        <div class="analysis-row-2">
                            <div class="analysis-card loading-card">
                                <div class="card-header">
                                    <h4><i class="fas fa-chart-line"></i> EMA Analysis</h4>
                                    <div class="loading-spinner"><i class="fas fa-spinner fa-spin"></i> Calculating EMA...</div>
                                </div>
                            </div>
                            <div class="analysis-card loading-card">
                                <div class="card-header">
                                    <h4><i class="fas fa-chart-bar"></i> DMA Analysis</h4>
                                    <div class="loading-spinner"><i class="fas fa-spinner fa-spin"></i> Calculating DMA...</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }
        
        // Universal function to run all scanners
        async function runAllScanners(symbol = null, isAutoRun = false) {
            const selectedSymbol = symbol || document.getElementById('symbols').value;
            
            if (!selectedSymbol || selectedSymbol.trim() === '') {
                alert('Please select a symbol first');
                return;
            }
            
            const scanners = ['rsi', 'ema', 'dma', 'macd', 'volume'];
            const originalScanner = currentScanner;
            const analysisResults = {};
            
            // Update progress for each scanner
            for (let i = 0; i < scanners.length; i++) {
                const scanner = scanners[i];
                
                // Update loading state
                if (!isAutoRun) {
                    updateLoadingProgress(scanner.toUpperCase(), i + 1, scanners.length);
                }
                
                console.log(`Running ${scanner.toUpperCase()} scanner for ${selectedSymbol}...`);
                
                // Switch to scanner and load its config
                currentScanner = scanner;
                showScannerParams(scanner);
                await loadConfigForScanner(scanner);
                
                // Run the scanner
                await runScanner();
                
                // Store results
                analysisResults[scanner] = getCurrentAnalysisData(scanner);
                
                // Add delay between scanners (except for the last one)
                if (i < scanners.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
            }
            
            // Restore original scanner
            currentScanner = originalScanner;
            showScannerParams(originalScanner);
            
            // IMPORTANT: Wait for all chart data to be loaded before triggering chart initialization
            console.log('All scanners completed, waiting for chart data to stabilize...');
            await new Promise(resolve => setTimeout(resolve, 1500)); // Wait for chart data
            
            // Trigger chart initialization after all scanners complete using existing system
            const analysisDisplay = document.getElementById('analysisDisplay');
            if (analysisDisplay && analysisDisplay.innerHTML.includes('chart-card')) {
                console.log('Triggering delayed chart initialization using existing system...');
                setTimeout(() => {
                    const hasRSI = scannerChartData.rsi && Object.keys(scannerChartData.rsi).length > 0;
                    const hasEMA = scannerChartData.ema && Object.keys(scannerChartData.ema).length > 0; 
                    const hasDMA = scannerChartData.dma && Object.keys(scannerChartData.dma).length > 0;
                    const hasMACD = scannerChartData.macd && Object.keys(scannerChartData.macd).length > 0;
                    
                    console.log('Final chart data check:', {
                        hasRSI: !!scannerChartData.rsi,
                        hasEMA: !!scannerChartData.ema,
                        hasDMA: !!scannerChartData.dma,
                        hasMACD: !!scannerChartData.macd
                    });
                    
                    // Auto-load the first available chart using existing system
                    if (hasRSI) {
                        switchAnalysisChartTab('rsi');
                    } else if (hasEMA) {
                        switchAnalysisChartTab('ema');
                    } else if (hasDMA) {
                        switchAnalysisChartTab('dma');
                    } else if (hasMACD) {
                        switchAnalysisChartTab('macd');
                    }
                }, 200);
            }
            
            return analysisResults;
        }
        
        // Update loading progress for manual runs
        function updateLoadingProgress(scannerName, current, total) {
            const analysisDisplay = document.getElementById('analysisDisplay');
            if (!analysisDisplay) return;
            
            const progressElement = analysisDisplay.querySelector('.analysis-loading-container .text-muted');
            if (progressElement) {
                progressElement.innerHTML = `
                    <i class="fas fa-sync fa-spin"></i> 
                    Running ${scannerName} analysis... (${current}/${total})
                `;
            }
        }
        
        // Manual run function for the button
        async function runAllAnalysisManually() {
            const selectedSymbol = document.getElementById('symbols').value;
            
            if (!selectedSymbol || selectedSymbol.trim() === '') {
                alert('Please select a symbol first');
                return;
            }
            
            // Show loading state for manual run
            showAnalysisLoadingState(selectedSymbol);
            
            try {
                await runAllScanners(selectedSymbol, false);
                console.log('Manual run completed for all scanners');
            } catch (error) {
                console.error('Error during manual run:', error);
                const analysisDisplay = document.getElementById('analysisDisplay');
                if (analysisDisplay) {
                    analysisDisplay.innerHTML = `
                        <div class="text-center text-danger p-4">
                            <i class="fas fa-exclamation-triangle"></i>
                            <div>Error running analysis for ${selectedSymbol}</div>
                            <small>Please try again or check the server logs</small>
                        </div>`;
                }
            }
        }
        
        // Manual run function for the button
        async function runAllAnalysisManually() {
            const selectedSymbol = document.getElementById('symbols').value;
            
            if (!selectedSymbol || selectedSymbol.trim() === '') {
                alert('Please select a symbol first');
                return;
            }
            
            // Show loading state for manual run
            showAnalysisLoadingState(selectedSymbol);
            
            try {
                await runAllScanners(selectedSymbol, false);
                console.log('Manual run completed for all scanners');
            } catch (error) {
                console.error('Error during manual run:', error);
                const analysisDisplay = document.getElementById('analysisDisplay');
                if (analysisDisplay) {
                    analysisDisplay.innerHTML = `
                        <div class="text-center text-danger p-4">
                            <i class="fas fa-exclamation-triangle"></i>
                            <div>Error running analysis for ${selectedSymbol}</div>
                            <small>Please try again or check the server logs</small>
                        </div>`;
                }
            }
        }
        
        // Get current analysis data for a scanner (placeholder)
        function getCurrentAnalysisData(scanner) {
            // This would return the current analysis data
            // Implementation depends on how data is stored
            return null;
        }

        // Update date and time display
        function updateDateTime() {
            const now = new Date();
            const options = {
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: true
            };
            const dateTimeString = now.toLocaleDateString('en-US', options);
            document.getElementById('currentDateTime').textContent = dateTimeString;
        }

        // Run scanner
        async function runScanner() {
            const runButton = document.getElementById('runButton');
            const originalText = runButton.innerHTML;

            // Update button state
            runButton.disabled = true;
            runButton.innerHTML = '<i class="fas fa-sync"></i> Running...';

            const resultsSection = document.getElementById('resultsSection');
            const loadingIndicator = document.getElementById('loadingIndicator');
            const resultsDisplay = document.getElementById('resultsDisplay');
            const statusMessage = document.getElementById('statusMessage');
            const statusText = document.getElementById('statusText');

            // Show loading
            resultsSection.classList.remove('hidden');
            loadingIndicator.classList.remove('hidden');
            resultsDisplay.style.display = 'none';
            statusMessage.classList.remove('hidden');
            statusText.textContent = `Running ${currentScanner.toUpperCase()} scanner...`;
            statusMessage.classList.remove('hidden');
            document.getElementById('statusMessageInner').className = 'alert alert-info';

            try {
                // Get parameters
                const params = getScannerParams(currentScanner);

                // Make API call to run scanner
                const response = await fetch('/api/run-scanner', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        scanner: currentScanner,
                        ...params
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();

                // Display results
                loadingIndicator.classList.add('hidden');
                resultsDisplay.style.display = 'block';

                if (data.output && data.output.trim()) {
                    // Clean the output to remove any problematic characters
                    let cleanOutput = data.output.replace(/[\u{1F600}-\u{1F64F}]/gu, '') // Remove emojis
                                               .replace(/[\u{1F300}-\u{1F5FF}]/gu, '') // Remove symbols
                                               .replace(/[\u{1F680}-\u{1F6FF}]/gu, '') // Remove transport
                                               .replace(/[\u{1F1E0}-\u{1F1FF}]/gu, '') // Remove flags
                                               .replace(/[\u{2600}-\u{26FF}]/gu, '');  // Remove misc symbols
                    document.getElementById('resultsOutput').textContent = cleanOutput;
                } else {
                    document.getElementById('resultsOutput').textContent = 'No output received from scanner. Check server logs.';
                }

                // Store results for export
                scannerResults[currentScanner] = data.results;
                scannerOutputs[currentScanner] = data.output;
                scannerChartData[currentScanner] = data.chartData;

                console.log('Results received for', currentScanner, { hasOutput: !!(data.output && data.output.trim()), chartDataKeys: data.chartData ? Object.keys(data.chartData) : null });
                
                // Save current form values to runtime config for future tab switches
                saveToRuntimeConfig(currentScanner);

                // Try to populate MACD chart data from parsed outputs if server didn't include chartData
                ensureMacdChartDataAvailable();

                // Update status
                if (data.returncode === 0) {
                    statusText.textContent = `${currentScanner.toUpperCase()} scanner completed successfully!`;
                    document.getElementById('statusMessageInner').className = 'alert alert-success';
                } else {
                    statusText.textContent = `${currentScanner.toUpperCase()} scanner completed with errors (code: ${data.returncode})`;
                    document.getElementById('statusMessageInner').className = 'alert alert-warning';
                }

                // Create chart if data available
                if (data.chartData) {
                    if (currentScanner === 'volume') {
                        // Ensure chartData.volume exists or try to build it from output
                        if (!data.chartData.volume && scannerOutputs.volume) {
                            ensureVolumeChartDataAvailable();
                        }
                        const vData = (data.chartData && data.chartData.volume) || scannerChartData.volume;
                        if (vData) {
                            // Create main price chart as a volume bar chart
                            try {
                                createVolumeBarChart(vData);
                            } catch (err) {
                                console.warn('Failed to create volume bar chart:', err);
                            }
                        } else {
                            // Fallback to generic createChart if server provided non-volume chartData
                            const chartType = document.getElementById('chartTypeSelect').value;
                            createChart(data.chartData, chartType);
                        }

                        // Also render the smaller analysis volume chart
                        try {
                            const analysisData = vData || scannerChartData.volume;
                            if (analysisData) renderVolumeAnalysisChart(analysisData);
                        } catch (err) {
                            console.warn('Failed to render analysis volume chart:', err);
                        }
                    } else {
                        const chartType = document.getElementById('chartTypeSelect').value;
                        createChart(data.chartData, chartType);
                    }
                }

                // Auto-refresh table if user is currently on table tab
                const tableTab = document.getElementById('tableTab');
                if (tableTab && tableTab.classList.contains('active')) {
                    updateTableDisplay();
                }

                // No force button shown in UI

                // Show and update current analysis section
                const analysisSection = document.getElementById('analysisSection');
                analysisSection.classList.remove('hidden');
                updateCurrentAnalysis(currentScanner);

            } catch (error) {
                console.error('Error running scanner:', error);
                loadingIndicator.classList.add('hidden');
                statusText.textContent = `Error: ${error.message}`;
                statusMessage.classList.remove('hidden');
                document.getElementById('statusMessageInner').className = 'alert alert-danger';
                document.getElementById('resultsOutput').textContent = `Scanner execution failed:\n${error.message}`;
                resultsDisplay.style.display = 'block';
            } finally {
                // Reset button
                runButton.disabled = false;
                runButton.innerHTML = originalText;
            }
        }

        // forceRenderMacd removed

        // Simple MACD preview generator for developer/testing convenience
        function macdPreview(target) {
            console.log('MACD preview invoked');
            const sample = {
                labels: ['09:00','09:15','09:30','09:45','10:00','10:15','10:30','10:45','11:00','11:15'],
                macd: [0.2,0.25,0.1,-0.05,-0.2,-0.3,-0.15,0.05,0.12,0.18],
                signal: [0.15,0.2,0.12,0.0,-0.1,-0.2,-0.12,0.02,0.08,0.13],
                histogram: [0.05,0.05,-0.02,-0.05,-0.1,-0.1,-0.03,0.03,0.04,0.05]
            };
            scannerChartData.macd = { ...sample, macd: sample };
            // Show preview button only for MACD; ensure chart type select is set
            document.getElementById('chartTypeSelect').value = 'macd';
            // If target === 'analysis', render into analysis canvas by temporarily swapping IDs
            if (target === 'analysis') {
                const analysisContainer = document.getElementById('analysisChartContainer');
                const analysisCanvas = document.getElementById('analysisChart');
                const mainContainer = document.getElementById('chartContainer');
                const mainCanvas = document.getElementById('priceChart');
                if (analysisContainer && analysisCanvas && mainContainer && mainCanvas) {
                    // Swap IDs
                    analysisContainer.id = 'chartContainer';
                    analysisCanvas.id = 'priceChart';
                    // Render
                    createChart(scannerChartData.macd, 'macd');
                    // Restore
                    analysisContainer.id = 'analysisChartContainer';
                    analysisCanvas.id = 'analysisChart';
                    return;
                }
            }

            // Default: render into main price chart
            createChart(scannerChartData.macd, 'macd');
        }

        // Render a compact volume chart inside the analysis area
        function renderVolumeAnalysisChart(volumeChartData) {
            if (!volumeChartData || !Array.isArray(volumeChartData.labels)) return;

            const canvas = document.getElementById('analysisVolumeChart');
            if (!canvas) return;

            // Create small Chart.js bar+line combo for volume and avg volume
            try {
                const ctx = canvas.getContext('2d');
                // Destroy any existing small chart stored on the element
                if (canvas._chartInstance) {
                    canvas._chartInstance.destroy();
                }

                const labels = volumeChartData.labels.slice(-50);
                const volumes = (volumeChartData.volumes || []).slice(-50);
                const avg = (volumeChartData.avgVolumes || []).slice(-50);

                const smallChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [
                            {
                                label: 'Volume',
                                data: volumes,
                                backgroundColor: 'rgba(59,130,246,0.6)'
                            },
                            {
                                label: 'Avg Vol',
                                data: avg,
                                type: 'line',
                                borderColor: 'rgba(34,197,94,0.9)',
                                backgroundColor: 'rgba(34,197,94,0.08)',
                                fill: false,
                                pointRadius: 0,
                                tension: 0.1
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: { display: false },
                            y: { display: true }
                        },
                        plugins: { legend: { display: true, position: 'top' } }
                    }
                });

                canvas._chartInstance = smallChart;
            } catch (err) {
                console.warn('renderVolumeAnalysisChart error:', err);
            }
        }

        // Get scanner parameters
        function getScannerParams(scannerType) {
            const baseParams = {
                symbols: [document.getElementById('symbols').value], // Single symbol selection
                baseTimeframe: document.getElementById('baseTimeframe').value,
                daysToList: parseInt(document.getElementById('daysToList').value)
            };

            switch (scannerType) {
                case 'rsi':
                    return {
                        ...baseParams,
                        rsiPeriods: document.getElementById('rsiPeriods').value.split(',').map(p => parseInt(p.trim())),
                        rsiOverbought: parseInt(document.getElementById('rsiOverbought').value),
                        rsiOversold: parseInt(document.getElementById('rsiOversold').value),
                        daysFallbackThreshold: parseInt(document.getElementById('rsiDaysFallback').value)
                    };
                case 'ema':
                    return {
                        ...baseParams,
                        emaPeriods: document.getElementById('emaPeriods').value.split(',').map(p => parseInt(p.trim())),
                        daysFallbackThreshold: parseInt(document.getElementById('emaDaysFallback').value)
                    };
                case 'dma':
                    return {
                        ...baseParams,
                        dmaPeriods: document.getElementById('dmaPeriods').value.split(',').map(p => parseInt(p.trim())),
                        daysFallbackThreshold: parseInt(document.getElementById('dmaDaysFallback').value)
                    };
                case 'macd':
                    return {
                        ...baseParams,
                        fastLength: parseInt(document.getElementById('macdFastLength').value),
                        slowLength: parseInt(document.getElementById('macdSlowLength').value),
                        signalLength: parseInt(document.getElementById('macdSignalLength').value),
                        oscillatorMAType: document.getElementById('macdOscillatorMA').value,
                        signalMAType: document.getElementById('macdSignalMA').value,
                        daysFallbackThreshold: parseInt(document.getElementById('macdDaysFallback').value)
                    };
                case 'volume':
                    return {
                        ...baseParams,
                        maWindow: parseInt(document.getElementById('volumeMaWindow').value),
                        multiplier: parseFloat(document.getElementById('volumeMultiplier').value),
                        minVolume: parseInt(document.getElementById('volumeMinVolume').value),
                        daysFallbackThreshold: parseInt(document.getElementById('volumeDaysFallback').value)
                    };
                default:
                    return baseParams;
            }
        }

        // Create chart
        function createChart(chartData, chartType = 'line') {
            console.log('Creating chart with type:', chartType);
            console.log('Chart data:', chartData);
            
            const chartContainer = document.getElementById('chartContainer');
            chartContainer.style.display = 'block';

            const ctx = document.getElementById('priceChart').getContext('2d');

            if (chart) {
                chart.destroy();
            }

            // Apply dark mode colors if needed
            const isDark = isDarkMode;
            const textColor = isDark ? '#f9fafb' : '#374151';
            const gridColor = isDark ? '#4b5563' : '#e5e7eb';

            Chart.defaults.color = textColor;
            Chart.defaults.borderColor = gridColor;

            // Prepare datasets based on chart type
            let processedDatasets = [];

            if (chartType === 'candlestick') {
                // Check if financial chart library is available
                const hasFinancialChart = typeof Chart !== 'undefined' && Chart.controllers && Chart.controllers.candlestick;
                console.log('Financial chart library available:', hasFinancialChart);
                
                const ohlcDataset = chartData.datasets.find(ds => ds.label === 'OHLC');
                console.log('OHLC Dataset:', ohlcDataset);
                
                if (ohlcDataset && ohlcDataset.data && ohlcDataset.data.length > 0) {
                    console.log('OHLC data sample:', ohlcDataset.data.slice(0, 3));
                    
                    if (hasFinancialChart) {
                        // Use financial chart library
                        // Simple approach: create candlestick data points
                        const candlestickData = ohlcDataset.data.map((ohlc, index) => {
                            if (Array.isArray(ohlc) && ohlc.length >= 4) {
                                const [open, high, low, close] = ohlc;
                                return {
                                    x: index,  // Use simple index for positioning
                                    o: open,
                                    h: high,
                                    l: low,
                                    c: close
                                };
                            }
                            return null;
                        }).filter(item => item !== null);
                        
                        processedDatasets.push({
                            label: 'Candlestick',
                            data: candlestickData,
                            type: 'candlestick',
                            color: {
                                up: 'rgb(34, 197, 94)',
                                down: 'rgb(239, 68, 68)',
                                unchanged: 'rgb(59, 130, 246)'
                            },
                            borderColor: {
                                up: 'rgb(34, 197, 94)',
                                down: 'rgb(239, 68, 68)',
                                unchanged: 'rgb(59, 130, 246)'
                            }
                        });
                        
                        // Add indicators to candlestick chart
                        const indicatorDatasets = chartData.datasets.filter(ds => 
                            ds.label !== 'OHLC' && 
                            (ds.label.includes('RSI') || ds.label.includes('EMA') || ds.label.includes('DMA'))
                        );
                        
                        // Add each indicator dataset with styling
                        indicatorDatasets.forEach(ds => {
                            // Create simple data mapping with indices
                            const mappedData = ds.data.map((val, index) => ({
                                x: index,
                                y: val
                            }));
                            
                            processedDatasets.push({
                                label: ds.label,
                                data: mappedData,
                                type: 'line',
                                borderWidth: 2,       // Thicker for better visibility
                                pointRadius: 0,       // No points for cleaner look
                                tension: 0.1,         // Slight smoothing for lines
                                borderColor: ds.borderColor || ds.backgroundColor,
                                backgroundColor: ds.backgroundColor,
                                fill: false,
                                // Send RSI to secondary y-axis
                                yAxisID: ds.label.includes('RSI') ? 'y1' : 'y'
                            });
                        });
                    } else {
                        // Fallback: Create simple candlestick representation
                        console.log('Using fallback candlestick implementation');
                        
                        const bodyData = [];
                        const wickData = [];
                        
                        ohlcDataset.data.forEach((ohlc, index) => {
                            if (Array.isArray(ohlc) && ohlc.length >= 4) {
                                const [open, high, low, close] = ohlc;
                                const isGreen = close >= open;
                                const color = isGreen ? 'rgb(34, 197, 94)' : 'rgb(239, 68, 68)';
                                
                                // Body (open-close)
                                if (Math.abs(close - open) > 0.01) { // Only show body if there's a difference
                                    const bodyTop = Math.max(open, close);
                                    const bodyBottom = Math.min(open, close);
                                    bodyData.push({
                                        x: index,
                                        y: bodyBottom + (bodyTop - bodyBottom) / 2,
                                        height: bodyTop - bodyBottom,
                                        color: color
                                    });
                                }
                                
                                // Wick (high-low) - simplified as points
                                wickData.push({
                                    x: index,
                                    y: low,
                                    color: color
                                });
                                wickData.push({
                                    x: index,
                                    y: high,
                                    color: color
                                });
                            }
                        });
                        
                        // Add body bars
                        if (bodyData.length > 0) {
                            processedDatasets.push({
                                label: 'Candlestick Body',
                                data: bodyData.map(d => d.y),
                                backgroundColor: bodyData.map(d => d.color),
                                borderColor: bodyData.map(d => d.color),
                                type: 'bar',
                                barThickness: 4,
                                categoryPercentage: 0.6
                            });
                        }
                        
                        // Add wick points (simplified)
                        processedDatasets.push({
                            label: 'High-Low',
                            data: wickData,
                            type: 'scatter',
                            pointStyle: 'rect',
                            pointRadius: 2,
                            backgroundColor: wickData.map(d => d.color),
                            borderColor: wickData.map(d => d.color)
                        });
                    }

                } else {
                    console.warn('No OHLC data available, falling back to line chart');
                    chartType = 'line';
                }
            }

            if (chartType === 'line') {
                // Start fresh and build datasets properly
                processedDatasets = [];

                // Add all non-OHLC datasets first
                const datasetsArr = Array.isArray(chartData.datasets) ? chartData.datasets : [];
                const allLineDatasets = datasetsArr.filter(ds => ds && ds.label !== 'OHLC');

                // Process each dataset with appropriate styling
                allLineDatasets.forEach(ds => {
                    if (ds.label === 'Close Price') {
                        // Special styling for Close Price
                        processedDatasets.push({
                            ...ds,
                            borderWidth: 3,  // Thicker for prominence
                            borderColor: '#2563eb',  // Blue color
                            backgroundColor: '#2563eb',
                            pointRadius: 2,  // Small points for visibility
                            fill: false,  // No fill for line chart
                            type: 'line'  // Force line type
                        });
                    } else if (ds.label.includes('RSI') || ds.label.includes('EMA') || ds.label.includes('DMA')) {
                        // Thinner styling for indicators
                        processedDatasets.push({
                            ...ds,
                            borderWidth: 1,  // Thinner for indicators
                            pointRadius: 0,  // No points for cleaner look
                            type: 'line'  // Force line type for indicators
                        });
                    } else {
                        // Default styling for other datasets
                        processedDatasets.push({
                            ...ds,
                            type: 'line'  // Force line type
                        });
                    }
                });
            }

            // Custom MACD visualization: vertical histogram + MACD & Signal lines
            if (chartType === 'macd') {
                processedDatasets = [];

                // Try to find MACD related datasets in chartData (guard datasets missing)
                const datasetsArr = Array.isArray(chartData.datasets) ? chartData.datasets : [];
                const histDs = datasetsArr.find(ds => ds && ds.label && ds.label.toLowerCase().includes('histogram')) || null;
                const macdDs = datasetsArr.find(ds => ds && ds.label && ds.label.toLowerCase().includes('macd') && !ds.label.toLowerCase().includes('hist')) || null;
                const sigDs = datasetsArr.find(ds => ds && ds.label && ds.label.toLowerCase().includes('signal')) || null;

                // Fallback if datasets are provided in a different shape
                const labels = chartData.labels || (chartData.macd && chartData.macd.labels) || [];
                const histogramValues = (histDs && histDs.data) || (chartData.macd && chartData.macd.histogram) || [];
                const macdValues = (macdDs && macdDs.data) || (chartData.macd && chartData.macd.macd) || [];
                const signalValues = (sigDs && sigDs.data) || (chartData.macd && chartData.macd.signal) || [];

                // Ensure arrays have same length by trimming to shortest
                const minLen = Math.min(labels.length || Infinity, histogramValues.length || Infinity, macdValues.length || Infinity, signalValues.length || Infinity) || 0;
                const useLabels = labels.slice(-minLen);
                const useHist = histogramValues.slice(-minLen);
                const useMacd = macdValues.slice(-minLen);
                const useSig = signalValues.slice(-minLen);

                // Colors for bars
                const barColors = useHist.map(v => v > 0 ? 'rgba(40,167,69,0.85)' : v < 0 ? 'rgba(220,53,69,0.85)' : 'rgba(108,117,125,0.7)');

                // Compute symmetric y-limit
                const allAbs = [].concat(useHist, useMacd, useSig).map(Math.abs);
                const maxAbs = Math.max(1, ...(allAbs.length ? allAbs : [1]));
                const yLimit = Math.ceil(maxAbs * 1.1 * 10000) / 10000;

                // Histogram (bar)
                processedDatasets.push({
                    label: 'MACD Histogram',
                    data: useHist,
                    backgroundColor: barColors,
                    borderWidth: 0,
                    type: 'bar',
                    barThickness: 8
                });

                // MACD line
                processedDatasets.push({
                    label: 'MACD',
                    data: useMacd,
                    type: 'line',
                    borderColor: 'rgba(40,167,69,1)',
                    backgroundColor: 'rgba(40,167,69,0.05)',
                    pointRadius: 0,
                    borderWidth: 2,
                    tension: 0.2
                });

                // Signal line
                processedDatasets.push({
                    label: 'Signal',
                    data: useSig,
                    type: 'line',
                    borderColor: 'rgba(255,193,7,1)',
                    backgroundColor: 'rgba(255,193,7,0.03)',
                    pointRadius: 0,
                    borderWidth: 2,
                    tension: 0.2
                });

                // override labels and scales for macd view
                chartData.labels = useLabels;
                // attach yLimit for later use in options
                chartData._macdYLimit = yLimit;
            }

            // Prepare scales configuration
            const scales = {
                x: {
                    display: true,
                    title: {
                        display: true,
                        text: 'Time',
                        color: textColor
                    },
                    grid: {
                        color: gridColor
                    },
                    ticks: {
                        color: textColor
                    }
                },
                y: {
                    display: true,
                    title: {
                        display: true,
                        text: 'Price',
                        color: textColor
                    },
                    grid: {
                        color: gridColor
                    },
                    ticks: {
                        color: textColor
                    }
                }
            };

            // For candlestick charts, we need specialized scale configuration
            if (chartType === 'candlestick') {
                // Simple approach: set up basic time labels
                scales.x = {
                    type: 'linear',
                    position: 'bottom',
                    title: {
                        display: true,
                        text: 'Time',
                        color: textColor
                    },
                    grid: {
                        color: gridColor,
                        drawOnChartArea: true
                    },
                    ticks: {
                        stepSize: 5,  // Show a label every 5 data points
                        callback: function(value) {
                            // Only show labels for integer indices that match data points
                            if (Number.isInteger(value) && 
                                chartData.labels && 
                                value >= 0 && 
                                value < chartData.labels.length) {
                                
                                // Get the label at this index
                                const label = chartData.labels[value];
                                
                                // Format time label
                                if (typeof label === 'string') {
                                    if (label.includes(':')) {
                                        // Extract just time portion if it has a colon
                                        return label.split(' ').find(part => part.includes(':')) || label;
                                    }
                                    return label;
                                }
                                return label;
                            }
                            return '';
                        },
                        color: textColor,
                        maxRotation: 0,
                        autoSkip: false,
                        font: {
                            size: 10  // Slightly smaller font for more labels
                        }
                    }
                }
            }

            // Add secondary Y-axis for RSI
            if (currentScanner === 'rsi') {
                scales.y1 = {
                    display: true,
                    position: 'right',
                    title: {
                        display: true,
                        text: 'RSI',
                        color: textColor
                    },
                    grid: {
                        drawOnChartArea: false,
                        color: gridColor
                    },
                    ticks: {
                        color: textColor,
                        min: 0,
                        max: 100
                    }
                };
            }

            // If macd chart, enforce symmetric y-axis if available
            if (chartType === 'macd' && chartData._macdYLimit) {
                scales.y.min = -chartData._macdYLimit;
                scales.y.max = chartData._macdYLimit;
                // label change
                scales.y.title.text = 'MACD / Histogram';
            }

            chart = new Chart(ctx, {
                type: (chartType === 'candlestick' && typeof Chart !== 'undefined' && Chart.controllers && Chart.controllers.candlestick) ? 'candlestick' : 'line',
                data: {
                    labels: chartData.labels,
                    datasets: processedDatasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: scales,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                color: textColor
                            }
                        },
                        tooltip: {
                            // Custom tooltip to show proper time labels
                            callbacks: {
                                title: function(tooltipItems) {
                                    // Get index from the candlestick data point
                                    const index = tooltipItems[0].dataIndex;
                                    // Use that to lookup the actual time label
                                    if (chartData.labels && index >= 0 && index < chartData.labels.length) {
                                        return chartData.labels[index];
                                    }
                                    return '';
                                },
                                label: function(context) {
                                    // Different formatting for different dataset types
                                    const label = context.dataset.label || '';
                                    
                                    if (label === 'Candlestick') {
                                        const dataPoint = context.raw;
                                        if (dataPoint) {
                                            return [
                                                `O: ${dataPoint.o.toFixed(1)}`,
                                                `H: ${dataPoint.h.toFixed(1)}`,
                                                `L: ${dataPoint.l.toFixed(1)}`,
                                                `C: ${dataPoint.c.toFixed(1)}`
                                            ];
                                        }
                                    } else if (label.includes('RSI')) {
                                        const value = context.parsed.y;
                                        return `${label}: ${value.toFixed(3)}`;
                                    }
                                    
                                    // Default label formatting
                                    const value = context.parsed.y;
                                    return `${label}: ${value}`;
                                }
                            },
                            backgroundColor: isDarkMode ? 'rgba(0, 0, 0, 0.8)' : 'rgba(255, 255, 255, 0.8)',
                            titleColor: textColor,
                            bodyColor: textColor,
                            borderColor: gridColor,
                            borderWidth: 1
                        }
                    },
                    elements: {
                        point: {
                            radius: 2,
                            hoverRadius: 4
                        },
                        line: {
                            borderWidth: 2
                        }
                    }
                }
            });
        }

        // Export results
        function exportResults() {
            if (!scannerResults[currentScanner]) {
                alert('No results to export. Please run a scanner first.');
                return;
            }

            const csvContent = convertToCSV(scannerResults[currentScanner]);
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');

            if (link.download !== undefined) {
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', `${currentScanner}_results_${new Date().toISOString().split('T')[0]}.csv`);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }

        // Convert results to CSV
        function convertToCSV(data) {
            if (!data || !Array.isArray(data) || data.length === 0) {
                return '';
            }

            const headers = Object.keys(data[0]);
            const csvRows = [];

            // Add headers
            csvRows.push(headers.join(','));

            // Add data rows
            data.forEach(row => {
                const values = headers.map(header => {
                    const value = row[header];
                    // Handle null/undefined values and escape commas/quotes
                    if (value === null || value === undefined) {
                        return '';
                    }
                    const stringValue = String(value);
                    if (stringValue.includes(',') || stringValue.includes('"') || stringValue.includes('\n')) {
                        return `"${stringValue.replace(/"/g, '""')}"`;
                    }
                    return stringValue;
                });
                csvRows.push(values.join(','));
            });

            return csvRows.join('\n');
        }

        // Change chart type when dropdown is changed
        function changeChartType() {
            const chartType = document.getElementById('chartTypeSelect').value;
            currentChartType = chartType;
            console.log('Chart type changed to:', chartType);
            
            // Recreate chart with new type
            // Only create chart if data exists for the active scanner
            const data = scannerChartData[currentScanner];
            if (!data) {
                console.warn('No chart data for current scanner:', currentScanner);
                if (chart) { chart.destroy(); chart = null; }
                return;
            }

            // If chartType is macd but current scanner is not macd, ignore
            if (chartType === 'macd' && currentScanner !== 'macd') {
                console.warn('MACD chart type selected but current scanner is not MACD. Ignoring.');
                return;
            }

            createChart(data, chartType);
        }
        
        // Clear results
        function clearResults() {
            document.getElementById('resultsSection').classList.add('hidden');
            document.getElementById('statusMessage').classList.add('hidden');
            document.getElementById('chartContainer').style.display = 'none';
            document.getElementById('resultsOutput').textContent = '';
            scannerResults = {
                rsi: null,
                ema: null,
                dma: null,
                macd: null,
                volume: null
            };

            if (chart) {
                chart.destroy();
                chart = null;
            }
        }

        // Clear all results and hide section
        function clearAllResults() {
            document.getElementById('resultsSection').classList.add('hidden');
            document.getElementById('statusMessage').classList.add('hidden');
            document.getElementById('chartContainer').style.display = 'none';
            document.getElementById('resultsOutput').textContent = '';
            scannerResults = {
                rsi: null,
                ema: null,
                dma: null,
                macd: null,
                volume: null
            };

            // Reset tabs to default state
            document.querySelectorAll('.tab-button').forEach(tab => tab.classList.remove('active'));
            document.getElementById('tableTab').classList.add('active');

            // Hide all content and show table
            document.getElementById('resultsTabContent').classList.add('hidden');
            document.getElementById('chartTabContent').classList.add('hidden');
            document.getElementById('tableTabContent').classList.remove('hidden');
        }

        // Switch between scanner tabs
        function switchScannerTab(scannerType) {
            // Update current scanner
            currentScanner = scannerType;

            // Update scanner type dropdown
            document.getElementById('scannerType').value = scannerType;

            // Update tab styles - reset all
            document.querySelectorAll('#rsiScannerTab, #emaScannerTab, #dmaScannerTab, #macdScannerTab, #volumeScannerTab').forEach(tab => {
                tab.classList.remove('active');
            });

            // Set active tab
            const activeTab = document.getElementById(scannerType + 'ScannerTab');
            if (activeTab) {
                activeTab.classList.add('active');
            }

            // Show scanner parameters
            showScannerParams(scannerType);
            
            // Try to load from runtime config first, fallback to base config if not available
            const loadedFromRuntime = loadFromRuntimeConfig(scannerType);
            if (!loadedFromRuntime) {
                // Load config from base config file (first time access)
                loadConfigForScanner(scannerType);
            }

            // Fetch stored results for this scanner
            fetchStoredResults(scannerType);

            // Update chart-type options and auto-render if needed
            updateChartTypeOptions(scannerType);

            // If the Price Chart tab is active and we've switched to MACD, try to auto-render
            const chartTab = document.getElementById('chartTab');
            const chartTabContent = document.getElementById('chartTabContent');
            if (scannerType === 'macd' && chartTab && chartTab.classList.contains('active')) {
                // Try to populate and render the MACD chart with a small retry/backoff to
                // handle timing where scannerOutputs.macd may arrive slightly after UI updates.
                renderMacdWithRetry(3, 250);
            }
        }

        // Fetch stored results from server
        async function fetchStoredResults(scannerType) {
            try {
                const response = await fetch(`/api/scanner-results/${scannerType}`);
                if (response.ok) {
                    const data = await response.json();

                    // Store results locally
                    scannerResults[scannerType] = data.results;
                    scannerOutputs[scannerType] = data.output || '';
                    scannerChartData[scannerType] = data.chart_data;
                    // Try to populate macd chart data from outputs if server didn't provide chart_data
                    ensureMacdChartDataAvailable();

                    // Display results
                    displayScannerResults(scannerType);

                    // Show results section if we have data
                    const resultsSection = document.getElementById('resultsSection');
                    if (data.results || data.output) {
                        resultsSection.classList.remove('hidden');
                    }
                } else {
                    console.warn(`No stored results for ${scannerType}`);
                    displayScannerResults(scannerType);
                }
            } catch (error) {
                console.error('Error fetching stored results:', error);
                displayScannerResults(scannerType);
            }
        }

        // Switch between content tabs (Table/Chart/Results)
        function switchContentTab(tab) {
            const resultsTabContent = document.getElementById('resultsTabContent');
            const tableTabContent = document.getElementById('tableTabContent');
            const chartTabContent = document.getElementById('chartTabContent');
            const resultsTab = document.getElementById('resultsTab');
            const tableTab = document.getElementById('tableTab');
            const chartTab = document.getElementById('chartTab');

            // Reset all tab styles
            resultsTab.classList.remove('active');
            tableTab.classList.remove('active');
            chartTab.classList.remove('active');

            // Hide all content
            resultsTabContent.classList.add('hidden');
            tableTabContent.classList.add('hidden');
            chartTabContent.classList.add('hidden');

            if (tab === 'table') {
                tableTab.classList.add('active');
                tableTabContent.classList.remove('hidden');
                // Update table display when switching to table tab
                updateTableDisplay();
            } else if (tab === 'chart') {
                chartTab.classList.add('active');
                chartTabContent.classList.remove('hidden');
                // Update chart-type options for the current scanner
                updateChartTypeOptions(currentScanner);
                // Recreate chart with current type when switching to chart tab
                if (currentScanner === 'volume') {
                    // If we have real volume data, render it; otherwise show preview to avoid empty chart
                    if (scannerChartData.volume && Array.isArray(scannerChartData.volume.labels) && scannerChartData.volume.labels.length > 0) {
                        try { createVolumeBarChart(scannerChartData.volume); } catch (e) { console.warn('createVolumeBarChart failed', e); }
                    } else {
                        try { volumePreview(); } catch (e) { console.warn('volumePreview failed', e); }
                    }
                } else {
                    if (scannerChartData[currentScanner]) {
                        const chartType = document.getElementById('chartTypeSelect').value;
                        createChart(scannerChartData[currentScanner], chartType);
                    }
                }
            } else if (tab === 'results') {
                resultsTab.classList.add('active');
                resultsTabContent.classList.remove('hidden');
            }
        }

        // Convert DD-MM-YYYY H:MM:SS format to JavaScript Date
        function convertTimeStringToDate(timeStr) {
            if (!timeStr || timeStr.trim() === '') {
                return null;
            }
            
            // Expected format: "16-09-2025 14:15:00"
            const parts = timeStr.trim().split(' ');
            if (parts.length !== 2) {
                return null;
            }
            
            const datePart = parts[0]; // "16-09-2025"
            const timePart = parts[1]; // "14:15:00"
            
            const dateComponents = datePart.split('-');
            if (dateComponents.length !== 3) {
                return null;
            }
            
            const day = parseInt(dateComponents[0]);
            const month = parseInt(dateComponents[1]) - 1; // JavaScript months are 0-based
            const year = parseInt(dateComponents[2]);
            
            const timeComponents = timePart.split(':');
            if (timeComponents.length !== 3) {
                return null;
            }
            
            const hour = parseInt(timeComponents[0]);
            const minute = parseInt(timeComponents[1]);
            const second = parseInt(timeComponents[2]);
            
            return new Date(year, month, day, hour, minute, second);
        }

        // Format time string for display based on timeframe
        // For 'daily' and longer timeframes show only date, for sub-daily show date and HH:MM
        function formatTimeForDisplay(timeStr, timeframe) {
            if (!timeStr || timeStr.trim() === '') return '--';
            // Accept either "DD-MM-YYYY HH:MM:SS" or ISO-like strings; try to extract date and time
            const parts = timeStr.trim().split(' ');
            const datePart = parts[0] || timeStr;
            const timePart = parts[1] || '';

            // Decide if timeframe is sub-daily (contains 'min' or 'hour')
            const tf = String(timeframe || '').toLowerCase();
            const isSubDaily = tf.includes('min') || tf.includes('hour');

            if (isSubDaily) {
                // Show date + HH:MM (drop seconds)
                if (timePart) {
                    const timePieces = timePart.split(':');
                    if (timePieces.length >= 2) {
                        return `${datePart} ${timePieces[0]}:${timePieces[1]}`;
                    }
                }
                return datePart; // fallback
            }

            // For daily+ only show date
            return datePart;
        }

        // Human-friendly number formatter (e.g., 1,234 -> 1.2K, 2,500,000 -> 2.50M)
        function formatNumberForDisplay(value) {
            if (value === null || value === undefined) return '';
            const raw = typeof value === 'number' ? value : parseFloat(String(value).replace(/,/g, ''));
            if (!isFinite(raw)) return String(value);
            const n = Math.trunc(raw);
            const abs = Math.abs(n);
            if (abs >= 1_000_000_000) return (n / 1_000_000_000).toFixed(2) + 'B';
            if (abs >= 1_000_000) return (n / 1_000_000).toFixed(2) + 'M';
            if (abs >= 1_000) return (n / 1_000).toFixed(1) + 'K';
            return n.toLocaleString();
        }

        // Save current form values to runtime config for the current scanner
        function saveToRuntimeConfig(scannerType) {
            const config = {
                symbol: document.getElementById('symbols').value,
                baseTimeframe: document.getElementById('baseTimeframe').value,
                daysToList: parseInt(document.getElementById('daysToList').value)
            };
            
            // Add scanner-specific parameters
            if (scannerType === 'rsi') {
                config.rsiPeriods = document.getElementById('rsiPeriods').value;
                config.rsiOverbought = parseInt(document.getElementById('rsiOverbought').value);
                config.rsiOversold = parseInt(document.getElementById('rsiOversold').value);
                config.daysFallbackThreshold = parseInt(document.getElementById('rsiDaysFallback').value);
            } else if (scannerType === 'ema') {
                config.emaPeriods = document.getElementById('emaPeriods').value;
                config.daysFallbackThreshold = parseInt(document.getElementById('emaDaysFallback').value);
            } else if (scannerType === 'dma') {
                config.dmaPeriods = document.getElementById('dmaPeriods').value;
                config.daysFallbackThreshold = parseInt(document.getElementById('dmaDaysFallback').value);
            } else if (scannerType === 'macd') {
                config.macdFastLength = parseInt(document.getElementById('macdFastLength').value);
                config.macdSlowLength = parseInt(document.getElementById('macdSlowLength').value);
                config.macdSignalLength = parseInt(document.getElementById('macdSignalLength').value);
                config.macdOscillatorMA = document.getElementById('macdOscillatorMA').value;
                config.macdSignalMA = document.getElementById('macdSignalMA').value;
                config.daysFallbackThreshold = parseInt(document.getElementById('macdDaysFallback').value);
            }
            
            runtimeConfig[scannerType] = config;
            useRuntimeConfig = true;
            console.log(`Saved runtime config for ${scannerType}:`, config);
        }
        
        // Load form values from runtime config for the specified scanner
        function loadFromRuntimeConfig(scannerType) {
            if (!useRuntimeConfig || !runtimeConfig[scannerType] || Object.keys(runtimeConfig[scannerType]).length === 0) {
                console.log(`No runtime config for ${scannerType}, will load from base config`);
                return false;
            }
            
            const config = runtimeConfig[scannerType];
            console.log(`Loading runtime config for ${scannerType}:`, config);
            
            // Load base parameters
            if (config.symbol) {
                document.getElementById('symbols').value = config.symbol;
            }
            if (config.baseTimeframe) {
                document.getElementById('baseTimeframe').value = config.baseTimeframe;
            }
            if (config.daysToList) {
                document.getElementById('daysToList').value = config.daysToList;
            }
            
            // Load scanner-specific parameters
            if (scannerType === 'rsi') {
                if (config.rsiPeriods) {
                    document.getElementById('rsiPeriods').value = config.rsiPeriods;
                }
                if (config.rsiOverbought) {
                    document.getElementById('rsiOverbought').value = config.rsiOverbought;
                }
                if (config.rsiOversold) {
                    document.getElementById('rsiOversold').value = config.rsiOversold;
                }
                if (config.daysFallbackThreshold) {
                    document.getElementById('rsiDaysFallback').value = config.daysFallbackThreshold;
                }
            } else if (scannerType === 'ema') {
                if (config.emaPeriods) {
                    document.getElementById('emaPeriods').value = config.emaPeriods;
                }
                if (config.daysFallbackThreshold) {
                    document.getElementById('emaDaysFallback').value = config.daysFallbackThreshold;
                }
            } else if (scannerType === 'dma') {
                if (config.dmaPeriods) {
                    document.getElementById('dmaPeriods').value = config.dmaPeriods;
                }
                if (config.daysFallbackThreshold) {
                    document.getElementById('dmaDaysFallback').value = config.daysFallbackThreshold;
                }
            } else if (scannerType === 'macd') {
                if (config.macdFastLength) {
                    document.getElementById('macdFastLength').value = config.macdFastLength;
                }
                if (config.macdSlowLength) {
                    document.getElementById('macdSlowLength').value = config.macdSlowLength;
                }
                if (config.macdSignalLength) {
                    document.getElementById('macdSignalLength').value = config.macdSignalLength;
                }
                if (config.macdOscillatorMA) {
                    document.getElementById('macdOscillatorMA').value = config.macdOscillatorMA;
                }
                if (config.macdSignalMA) {
                    document.getElementById('macdSignalMA').value = config.macdSignalMA;
                }
                if (config.daysFallbackThreshold) {
                    document.getElementById('macdDaysFallback').value = config.daysFallbackThreshold;
                }
            }
            
            return true;
        }

        // Update table display
        function updateTableDisplay() {
            const output = scannerOutputs[currentScanner];
            if (!output || !output.trim()) {
                document.getElementById('tableMessage').textContent = 'No data available. Please run a scanner first.';
                document.getElementById('tableMessage').classList.remove('hidden');
                document.getElementById('resultsTable').classList.add('hidden');
                return;
            }

            const tableData = parseScannerOutput(output);
            if (tableData && tableData.length > 0) {
                renderTable(tableData);
                document.getElementById('tableMessage').classList.add('hidden');
                document.getElementById('resultsTable').classList.remove('hidden');
            } else {
                document.getElementById('tableMessage').textContent = 'Unable to parse scanner output. Please check the Results tab.';
                document.getElementById('tableMessage').classList.remove('hidden');
                document.getElementById('resultsTable').classList.add('hidden');
            }
        }

        // Parse scanner output into table data
        // Parse scanner output into table data
        function parseScannerOutput(output) {
            const lines = output.split('\n').filter(line => line.trim());
            const tableData = [];

            // Check if output contains TABLE_DATA markers
            const hasTableDataMarkers = lines.some(line => line.includes('TABLE_DATA_START')) && lines.some(line => line.includes('TABLE_DATA_END'));

            // Check for legacy volume scanner CSV block markers
            const hasVolumeCsvBlock = lines.some(line => line.includes('VOLUME_SCANNER_OUTPUT_START')) && lines.some(line => line.includes('VOLUME_SCANNER_OUTPUT_END'));
            if (hasVolumeCsvBlock) {
                try {
                    let startIdx = lines.findIndex(l => l.includes('VOLUME_SCANNER_OUTPUT_START')) + 1;
                    let endIdx = lines.findIndex(l => l.includes('VOLUME_SCANNER_OUTPUT_END'));
                    if (endIdx === -1) endIdx = lines.length;

                    const section = lines.slice(startIdx, endIdx).map(l => l.trim()).filter(l => l);
                    if (section.length === 0) return tableData;

                    // First non-empty line should be CSV headers
                    const headerLine = section[0];
                    const headers = headerLine.split(',').map(h => h.trim());

                    // Regular expression to strip common log prefixes
                    const logPrefixRe = /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2},\d{3} - [^-]+ - (?:INFO|DEBUG|WARN|WARNING|ERROR|CRITICAL) -\s*/i;
                    const extraPrefixRe = /^__main__ - (?:INFO|DEBUG|WARN|WARNING|ERROR) -\s*/i;

                    for (let i = 1; i < section.length; i++) {
                        const line = section[i];
                        // split by comma but allow commas inside quotes (simple handling)
                        const cells = line.match(/(?:"([^"]*)")|([^,]+)/g) || [];
                        const cleaned = cells.map(c => {
                            if (c === null || c === undefined) return '';
                            // Remove surrounding quotes if present
                            let s = c.toString().trim();
                            if (s.startsWith('"') && s.endsWith('"')) s = s.slice(1, -1);
                            // Strip log prefixes
                            s = s.replace(logPrefixRe, '').replace(extraPrefixRe, '').trim();
                            return s;
                        });

                        // If the parsed cells count doesn't match headers, try a simple comma split fallback
                        const values = cleaned.length === headers.length ? cleaned : line.split(',').map(c => c.trim());

                        if (values.length === headers.length) {
                            const row = {};
                            headers.forEach((h, idx) => {
                                row[h] = values[idx] || '';
                            });
                            tableData.push(row);
                        }
                    }
                    return tableData;
                } catch (e) {
                    console.warn('Failed to parse VOLUME CSV block:', e);
                    // fallthrough to other parsing strategies
                }
            }

            if (hasTableDataMarkers) {
                // Parse only the TABLE_DATA section
                let inTableData = false;
                let headers = [];

                for (const line of lines) {
                    if (line.includes('TABLE_DATA_START')) {
                        inTableData = true;
                        continue;
                    } else if (line.includes('TABLE_DATA_END')) {
                        break;
                    } else if (inTableData && line.includes('|') && !line.includes('=')) {
                        const cells = line.split('|').map(cell => cell.trim()).filter(cell => cell);

                        if (headers.length === 0) {
                            // First line after TABLE_DATA_START is headers
                            headers = cells;
                        } else if (cells.length === headers.length) {
                            // This is data
                            const row = {};
                            // Remove common log prefixes like "2025-09-24 14:51:56,095 - __main__ - INFO - "
                            const logPrefixRe = /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2},\d{3} - [^-]+ - (?:INFO|DEBUG|WARN|WARNING|ERROR|CRITICAL) -\s*/i;
                            const extraPrefixRe = /^__main__ - (?:INFO|DEBUG|WARN|WARNING|ERROR) -\s*/i;
                            headers.forEach((header, index) => {
                                let cell = cells[index] || '';
                                if (typeof cell === 'string') {
                                    cell = cell.replace(logPrefixRe, '').replace(extraPrefixRe, '').trim();
                                }
                                row[header] = cell;
                            });
                            tableData.push(row);
                        }
                    }
                }
            } else {
                // Original parsing logic for outputs without TABLE_DATA markers
                let inTable = false;
                let headers = [];

                for (const line of lines) {
                    if (line.includes('|') && !line.includes('=')) {
                        const cells = line.split('|').map(cell => cell.trim()).filter(cell => cell);

                        if (!inTable) {
                            // This might be headers
                            if (cells.length >= 3 && cells.some(cell => cell.toUpperCase().includes('TIME') || cell.toUpperCase().includes('SYMBOL') || cell.toUpperCase().includes('CMP'))) {
                                headers = cells;
                                inTable = true;
                            }
                        } else {
                            // This is data
                            if (cells.length === headers.length) {
                                const row = {};
                                const logPrefixRe = /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2},\d{3} - [^-]+ - (?:INFO|DEBUG|WARN|WARNING|ERROR|CRITICAL) -\s*/i;
                                const extraPrefixRe = /^__main__ - (?:INFO|DEBUG|WARN|WARNING|ERROR) -\s*/i;
                                headers.forEach((header, index) => {
                                    let cell = cells[index] || '';
                                    if (typeof cell === 'string') {
                                        cell = cell.replace(logPrefixRe, '').replace(extraPrefixRe, '').trim();
                                    }
                                    row[header] = cell;
                                });
                                tableData.push(row);
                            }
                        }
                    } else if (line.includes('=') && inTable) {
                        // End of table
                        break;
                    }
                }
            }

            return tableData;
        }

        // Build MACD chart payload from parsed table rows (labels, histogram, macd, signal)
        function buildMacdChartDataFromTable(tableData) {
            if (!tableData || tableData.length === 0) return null;

            // Detect column names (case-insensitive)
            const firstRow = tableData[0];
            const keys = Object.keys(firstRow);
            let timeKey = keys.find(k => k.toLowerCase().includes('time')) || keys[0];
            let macdKey = keys.find(k => k.toLowerCase() === 'macd' || k.toLowerCase().includes('macd'));
            let signalKey = keys.find(k => k.toLowerCase() === 'signal' || k.toLowerCase().includes('signal'));
            let histKey = keys.find(k => k.toLowerCase() === 'histogram' || k.toLowerCase().includes('hist'));

            // Fallbacks: try to guess positions if exact names not present
            if (!macdKey) macdKey = keys.find(k => /macd/i.test(k));
            if (!signalKey) signalKey = keys.find(k => /signal/i.test(k));
            if (!histKey) histKey = keys.find(k => /hist/i.test(k));

            const labels = [];
            const macd = [];
            const signal = [];
            const histogram = [];

            const toNumber = v => {
                if (v === null || v === undefined) return NaN;
                // Remove commas and non-numeric characters except minus and dot
                const cleaned = String(v).replace(/[,\s]/g, '').replace(/[^0-9+\-\.eE]/g, '');
                const n = parseFloat(cleaned);
                return isNaN(n) ? NaN : n;
            };

            // Use the order provided in tableData; many scanners output newest-last — preserve that.
            for (const row of tableData) {
                const t = row[timeKey] || '';
                labels.push(t);

                macd.push(toNumber(macdKey ? row[macdKey] : row['MACD'] || row['macd'] || ''));
                signal.push(toNumber(signalKey ? row[signalKey] : row['SIGNAL'] || row['signal'] || ''));
                histogram.push(toNumber(histKey ? row[histKey] : row['HISTOGRAM'] || row['histogram'] || ''));
            }

            // Ensure arrays are numeric and of same length; trim leading NaNs if necessary
            const minLen = Math.min(labels.length, macd.length, signal.length, histogram.length);
            const out = {
                labels: labels.slice(-minLen),
                macd: macd.slice(-minLen).map(v => isNaN(v) ? 0 : v),
                signal: signal.slice(-minLen).map(v => isNaN(v) ? 0 : v),
                histogram: histogram.slice(-minLen).map(v => isNaN(v) ? 0 : v)
            };

            // If parsing produced no usable values, attempt a fallback: scan raw lines for numeric tokens
            const allZero = arr => Array.isArray(arr) && arr.length > 0 && arr.every(v => v === 0);
            if ((out.histogram.length === 0 || out.macd.length === 0) || (allZero(out.histogram) && allZero(out.macd) && allZero(out.signal))) {
                try {
                    const fallbackLabels = [];
                    const fallbackMacd = [];
                    const fallbackSignal = [];
                    const fallbackHist = [];

                    // Try to find the raw output string in a global variable if available
                    const raw = window.scannerOutputs && scannerOutputs.macd ? String(scannerOutputs.macd) : null;
                    if (raw) {
                        const lines = raw.split('\n').map(l => l.trim()).filter(l => l);
                        const numRe = /-?\d+(?:\.\d+)?/g;
                        for (const line of lines) {
                            const nums = line.match(numRe);
                            if (nums && nums.length >= 3) {
                                // Heuristic: assume last three numeric tokens are [MACD, Signal, Histogram] or [MACD, Signal, Hist]
                                const len = nums.length;
                                const macdVal = toNumber(nums[len - 3]);
                                const sigVal = toNumber(nums[len - 2]);
                                const histVal = toNumber(nums[len - 1]);
                                // Only accept if at least one is a finite number
                                if (isFinite(macdVal) || isFinite(sigVal) || isFinite(histVal)) {
                                    fallbackLabels.push('');
                                    fallbackMacd.push(isFinite(macdVal) ? macdVal : 0);
                                    fallbackSignal.push(isFinite(sigVal) ? sigVal : 0);
                                    fallbackHist.push(isFinite(histVal) ? histVal : 0);
                                }
                            }
                        }
                    }

                    if (fallbackMacd.length > 0) {
                        // Use the fallback arrays (take last N to keep recent)
                        const n = Math.min(fallbackMacd.length, 50);
                        return {
                            labels: fallbackLabels.slice(-n),
                            macd: fallbackMacd.slice(-n),
                            signal: fallbackSignal.slice(-n),
                            histogram: fallbackHist.slice(-n)
                        };
                    }
                } catch (e) {
                    console.warn('Fallback MACD parsing failed', e);
                }
            }

            return out;
        }

        // Ensure MACD chart data is available in scannerChartData.macd by converting parsed table output
        function ensureMacdChartDataAvailable() {
            try {
                if ((!scannerChartData.macd || !scannerChartData.macd.labels || scannerChartData.macd.labels.length === 0) && scannerOutputs.macd && scannerOutputs.macd.trim()) {
                    const table = parseScannerOutput(scannerOutputs.macd);
                    if (table && table.length > 0) {
                        const built = buildMacdChartDataFromTable(table);
                        if (built) {
                            // Provide canonical arrays at top-level and a separate macdObj for nested access
                            scannerChartData.macd = {
                                labels: built.labels,
                                macd: built.macd,
                                signal: built.signal,
                                histogram: built.histogram,
                                macdObj: {
                                    labels: built.labels,
                                    macd: built.macd,
                                    signal: built.signal,
                                    histogram: built.histogram
                                }
                            };
                            console.log('Populated scannerChartData.macd from parsed table output:', scannerChartData.macd);
                        }
                    }
                }
            } catch (e) {
                console.warn('Failed to populate MACD chart data from outputs:', e);
            }
        }

        // Build volume chart payload from parsed table rows
        function buildVolumeChartDataFromTable(tableData) {
            if (!tableData || tableData.length === 0) return null;

            // Detect possible column names
            const firstRow = tableData[0];
            const keys = Object.keys(firstRow);
            const timeKey = keys.find(k => k.toLowerCase().includes('time')) || keys[0];
            const volKey = keys.find(k => k.toLowerCase().includes('volume')) || keys.find(k => /vol/i.test(k));
            const avgKey = keys.find(k => k.toLowerCase().includes('avg') || k.toLowerCase().includes('avgvolume') || k.toLowerCase().includes('avg_vol')) || null;

            const labels = [];
            const volumes = [];
            const avgVolumes = [];

            const toNumber = v => {
                if (v === null || v === undefined) return NaN;
                const cleaned = String(v).replace(/[,\s]/g, '').replace(/[^0-9+\-\.eE]/g, '');
                const n = parseFloat(cleaned);
                return isNaN(n) ? NaN : n;
            };

            for (const row of tableData) {
                const t = row[timeKey] || '';
                labels.push(t);
                volumes.push(isNaN(toNumber(row[volKey])) ? 0 : toNumber(row[volKey]));
                if (avgKey) avgVolumes.push(isNaN(toNumber(row[avgKey])) ? 0 : toNumber(row[avgKey]));
                else avgVolumes.push(null);
            }

            // Trim to last 200 points to avoid large charts
            const maxPoints = 500;
            const start = Math.max(0, labels.length - maxPoints);

            return {
                labels: labels.slice(start),
                volumes: volumes.slice(start),
                avgVolumes: avgVolumes.slice(start)
            };
        }

        // Ensure volume chart data is available in scannerChartData.volume by parsing output
        function ensureVolumeChartDataAvailable() {
            try {
                if ((!scannerChartData.volume || !Array.isArray(scannerChartData.volume.labels) || scannerChartData.volume.labels.length === 0)
                    && scannerOutputs.volume && scannerOutputs.volume.trim()) {
                    const table = parseScannerOutput(scannerOutputs.volume);
                    if (table && table.length > 0) {
                        const built = buildVolumeChartDataFromTable(table);
                        if (built) {
                            scannerChartData.volume = built;
                            console.log('Populated scannerChartData.volume from parsed output', built);
                        }
                    }
                }
            } catch (e) {
                console.warn('Failed to populate volume chart data from outputs:', e);
            }
        }

        // Create a main bar-chart for volume in the Price Chart canvas
        function createVolumeBarChart(volumeChartData) {
            if (!volumeChartData || !Array.isArray(volumeChartData.labels) || volumeChartData.labels.length === 0) return;

            const ctx = document.getElementById('priceChart').getContext('2d');

            // Destroy existing global chart if any
            if (chart) {
                chart.destroy();
                chart = null;
            }

            const labels = volumeChartData.labels.slice(-200);
            const volumes = (volumeChartData.volumes || []).slice(-200);
            const avg = (volumeChartData.avgVolumes || []).slice(-200);

            const datasets = [
                {
                    label: 'Volume',
                    data: volumes,
                    backgroundColor: volumes.map(v => v > 0 ? 'rgba(59,130,246,0.7)' : 'rgba(108,117,125,0.4)'),
                    type: 'bar'
                }
            ];

            if (avg && avg.some(v => v !== null && v !== undefined)) {
                datasets.push({
                    label: 'Avg Volume',
                    data: avg,
                    type: 'line',
                    borderColor: 'rgba(34,197,94,0.9)',
                    backgroundColor: 'rgba(34,197,94,0.08)',
                    fill: false,
                    pointRadius: 0,
                    tension: 0.1,
                    yAxisID: 'y'
                });
            }

            chart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { display: true, title: { display: true, text: 'Time' } },
                        y: { display: true, title: { display: true, text: 'Volume' } }
                    },
                    plugins: { legend: { display: true, position: 'top' } }
                }
            });
        }

        // Render table with data
        function renderTable(data) {
            const tableBody = document.getElementById('tableBody');
            const tableHeaderRow = document.getElementById('tableHeaderRow');

            if (data.length === 0) {
                tableBody.innerHTML = '<tr><td colspan="4" class="px-4 py-2 text-center muted-text">No data to display</td></tr>';
                return;
            }

            // Sort data based on current sort settings
            const sortedData = [...data].sort((a, b) => {
                // Special sorting for MACD scanner - sort by MACD value in descending order
                const aKeys = Object.keys(a);
                const bKeys = Object.keys(b);
                if (currentScanner === 'macd' && (a['MACD'] !== undefined || aKeys.find(k=>/macd/i.test(k))) && (b['MACD'] !== undefined || bKeys.find(k=>/macd/i.test(k)))) {
                    const aMacdKey = aKeys.find(k => k.toLowerCase() === 'macd' || /macd/i.test(k));
                    const bMacdKey = bKeys.find(k => k.toLowerCase() === 'macd' || /macd/i.test(k));
                    const aMacd = parseFloat(aMacdKey ? a[aMacdKey] : a['MACD']) || 0;
                    const bMacd = parseFloat(bMacdKey ? b[bMacdKey] : b['MACD']) || 0;
                    return bMacd - aMacd; // Descending order (higher MACD values first)
                }

                if (currentSortColumn === 'Time') {
                    // Find time-like key in each row (handles log prefixes in header keys)
                    try {
                        const aTimeKey = Object.keys(a).find(k => k.toLowerCase().includes('time')) || 'Time';
                        const bTimeKey = Object.keys(b).find(k => k.toLowerCase().includes('time')) || 'Time';
                        const aTimeStr = a[aTimeKey] || '';
                        const bTimeStr = b[bTimeKey] || '';
                        const aTime = convertTimeStringToDate(aTimeStr);
                        const bTime = convertTimeStringToDate(bTimeStr);

                        if (!aTime || !bTime || isNaN(aTime.getTime()) || isNaN(bTime.getTime())) return 0;
                        return currentSortDirection === 'asc' ? aTime - bTime : bTime - aTime;
                    } catch (e) {
                        return 0;
                    }
                }
                return 0; // No sorting for other columns
            });

            // Get headers from first row (raw keys may contain log prefixes)
            const headers = Object.keys(sortedData[0]);

            // Detect the actual keys for Time, Symbol and CMP (case-insensitive)
            const timeKey = headers.find(h => h.toLowerCase().includes('time')) || 'Time';
            const symbolKey = headers.find(h => h.toLowerCase().includes('symbol')) || 'Symbol';
            const cmpKey = headers.find(h => h.toLowerCase().includes('cmp') || h.toLowerCase().includes('price') || h.toLowerCase().includes('last')) || 'CMP';

            // Create separate header cells for each indicator (exclude the canonical keys)
            const indicatorCols = headers.filter(h => h !== timeKey && h !== symbolKey && h !== cmpKey);

            // Clear existing indicator headers
            const existingHeaders = tableHeaderRow.querySelectorAll('th');
            existingHeaders.forEach((header, index) => {
                if (index > 2) header.remove(); // Remove headers beyond Time, Symbol, CMP
            });

            // Normalize header display name for indicator columns and add th elements
            const normalizeHeaderName = (h) => {
                const low = (h || '').toString().toLowerCase();
                if (low.includes('time')) return 'Time';
                if (low.includes('symbol')) return 'Symbol';
                if (low.includes('cmp') || low.includes('price') || low.includes('last')) return 'CMP';
                // Strip common log prefix patterns for display
                return (h || '').toString().replace(/^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2},\d{3} - [^-]+ - (?:INFO|DEBUG|WARN|WARNING|ERROR|CRITICAL) -\s*/i, '').replace(/^__main__ - (?:INFO|DEBUG|WARN|WARNING|ERROR) -\s*/i, '').trim();
            };

            indicatorCols.forEach(col => {
                const th = document.createElement('th');
                th.className = 'non-sortable'; // Remove sortable class
                th.innerHTML = `${normalizeHeaderName(col)} <span></span>`;
                tableHeaderRow.appendChild(th);
            });

            // Update sort icons
            updateSortIcons();

            // Update colspan for empty message
            const totalCols = 3 + indicatorCols.length; // Time, Symbol, CMP + indicators

            // Limit rows based on selection
            const rowsSelect = document.getElementById('tableRowsSelect');
            const maxRows = rowsSelect.value === 'all' ? sortedData.length : parseInt(rowsSelect.value);
            const displayData = sortedData.slice(0, maxRows);

            // Generate table rows
            const rows = displayData.map(row => {
                // Use detected timeKey for this dataset; fall back to any key that includes 'time'
                const rowKeys = Object.keys(row);
                const effectiveTimeKey = rowKeys.find(k => k.toLowerCase().includes('time')) || 'Time';
                const rawTime = row[effectiveTimeKey] || '';
                const tf = document.getElementById('baseTimeframe') ? document.getElementById('baseTimeframe').value : 'daily';
                const time = formatTimeForDisplay(rawTime, tf);
                const symbol = row['Symbol'] || '';
                const cmp = row['CMP'] || '';

                // Create indicator cells
                const indicatorCells = indicatorCols.map(col => {
                    const value = row[col] || '';
                    let cellClass = '';

                    // Color coding for RSI values
                    if (col.toUpperCase().includes('RSI')) {
                        const numValue = parseFloat(value);
                        if (!isNaN(numValue)) {
                            const overboughtThreshold = parseInt(document.getElementById('rsiOverbought').value) || 70;
                            const oversoldThreshold = parseInt(document.getElementById('rsiOversold').value) || 30;

                            if (numValue >= overboughtThreshold) {
                                cellClass = 'cell-overbought';
                            } else if (numValue <= oversoldThreshold) {
                                cellClass = 'cell-oversold';
                            }
                        }
                    }

                    // Color coding for EMA values with cross-period comparison
                    if (col.toUpperCase().includes('EMA')) {
                        const period = parseInt(col.replace('EMA', ''));
                        const numValue = parseFloat(value);

                        if (!isNaN(numValue)) {
                            if (period === 9 || period === 15) {
                                const ema9Value = row['EMA9'] ? parseFloat(row['EMA9']) : null;
                                const ema15Value = row['EMA15'] ? parseFloat(row['EMA15']) : null;

                                if (ema9Value !== null && ema15Value !== null && !isNaN(ema9Value) && !isNaN(ema15Value)) {
                                    if (ema9Value > ema15Value) {
                                        cellClass = 'cell-bull';
                                    } else {
                                        cellClass = 'cell-bear';
                                    }
                                }
                            }
                        }
                    }

                    // Color coding for DMA values (compare with CMP)
                    if (col.toUpperCase().includes('DMA')) {
                        const numValue = parseFloat(value);
                        const cmpValue = row['CMP'] ? parseFloat(row['CMP']) : null;

                        if (!isNaN(numValue) && cmpValue !== null && !isNaN(cmpValue)) {
                            if (numValue < cmpValue) {
                                cellClass = 'cell-bull';
                            } else {
                                cellClass = 'cell-bear';
                            }
                        }
                    }

                    // Color coding for MACD values
                    if (col.toUpperCase() === 'MACD') {
                        const numValue = parseFloat(value);
                        if (!isNaN(numValue)) {
                            if (numValue > 0) {
                                cellClass = 'cell-bull';
                            } else if (numValue < 0) {
                                cellClass = 'cell-bear';
                            }
                        }
                    }

                    // Color coding for Signal values
                    if (col.toUpperCase() === 'SIGNAL') {
                        const numValue = parseFloat(value);
                        if (!isNaN(numValue)) {
                            if (numValue > 0) {
                                cellClass = 'cell-bull';
                            } else if (numValue < 0) {
                                cellClass = 'cell-bear';
                            }
                        }
                    }

                    // Color coding for Histogram values
                    if (col.toUpperCase() === 'HISTOGRAM') {
                        const numValue = parseFloat(value);
                        if (!isNaN(numValue)) {
                            if (numValue > 0) {
                                cellClass = 'cell-bull';
                            } else if (numValue < 0) {
                                cellClass = 'cell-bear';
                            }
                        }
                    }

                    // Color coding for Status values
                    if (col.toUpperCase() === 'STATUS') {
                        const statusValue = value.toLowerCase();
                        if (statusValue.includes('bull')) {
                            cellClass = 'cell-bull';
                        } else if (statusValue.includes('bear')) {
                            cellClass = 'cell-bear';
                        }
                    }

                    return `<td class="${cellClass}">${value}</td>`;
                }).join('');

                return `
                    <tr>
                        <td>${time}</td>
                        <td>${symbol}</td>
                        <td>${cmp}</td>
                        ${indicatorCells}
                    </tr>
                `;
            }).join('');

            tableBody.innerHTML = rows;

            // Update empty message colspan
            const emptyRow = tableBody.querySelector('tr td[colspan]');
            if (emptyRow) {
                emptyRow.setAttribute('colspan', totalCols);
            }
        }

        // Display stored results for a scanner
        function displayScannerResults(scannerType) {
            const resultsOutput = document.getElementById('resultsOutput');
            const chartContainer = document.getElementById('chartContainer');
            const resultsSection = document.getElementById('resultsSection');

            // Display text output
            if (scannerOutputs[scannerType] && scannerOutputs[scannerType].trim()) {
                resultsOutput.textContent = scannerOutputs[scannerType];
                resultsSection.classList.remove('hidden');
            } else {
                resultsOutput.textContent = `No results available for ${scannerType.toUpperCase()} scanner.\n\nClick "Run" to execute the scanner and generate results.`;
                resultsSection.classList.add('hidden');
            }

            // Display chart if available
            // Try to populate macd chart data from parsed outputs if needed
            ensureMacdChartDataAvailable();

            if (scannerChartData[scannerType]) {
                const chartType = document.getElementById('chartTypeSelect').value;
                createChart(scannerChartData[scannerType], chartType);
                chartContainer.style.display = 'block';
            } else {
                chartContainer.style.display = 'none';
                if (chart) {
                    chart.destroy();
                    chart = null;
                }
            }

            // Update table display
            updateTableDisplay();

            // Update all analyses (unified view)
            updateAllAnalyses();

            // Ensure chart type options are correct for this scanner
            updateChartTypeOptions(scannerType);
        }



        // Update current analysis display
        function updateCurrentAnalysis(scannerType) {
            // Always update all analyses when any scanner completes
            updateAllAnalyses();
        }

        // Update all analyses in one comprehensive view
        function updateAllAnalyses() {
            const analysisMessage = document.getElementById('analysisMessage');
            const analysisDisplay = document.getElementById('analysisDisplay');
            
            // Check if we have data from all scanners
            const hasRSI = scannerOutputs['rsi'] && scannerOutputs['rsi'].trim();
            const hasEMA = scannerOutputs['ema'] && scannerOutputs['ema'].trim();
            const hasDMA = scannerOutputs['dma'] && scannerOutputs['dma'].trim();
            const hasMacd = scannerOutputs['macd'] && scannerOutputs['macd'].trim();
            const hasVolume = scannerOutputs['volume'] && scannerOutputs['volume'].trim();
            
            if (!hasRSI && !hasEMA && !hasDMA && !hasMacd) {
                analysisMessage.textContent = 'No analysis available. Please run scanners first to see trading signals.';
                analysisMessage.classList.remove('hidden');
                analysisDisplay.classList.add('hidden');
                return;
            }

            // Get latest records from each scanner
            const analyses = {};
            
            if (hasRSI) {
                const rsiData = parseScannerOutput(scannerOutputs['rsi']);
                if (rsiData && rsiData.length > 0) {
                    analyses.rsi = rsiData[rsiData.length - 1]; // Latest record (last in array)
                }
            }
            
            if (hasEMA) {
                const emaData = parseScannerOutput(scannerOutputs['ema']);
                if (emaData && emaData.length > 0) {
                    analyses.ema = emaData[emaData.length - 1]; // Latest record (last in array)
                }
            }
            
            if (hasDMA) {
                const dmaData = parseScannerOutput(scannerOutputs['dma']);
                if (dmaData && dmaData.length > 0) {
                    analyses.dma = dmaData[dmaData.length - 1]; // Latest record (last in array)
                }
            }
            
            if (hasMacd) {
                const macdData = parseScannerOutput(scannerOutputs['macd']);
                if (macdData && macdData.length > 0) {
                    analyses.macd = macdData; // Pass full array for table display
                }
            }

            if (hasVolume) {
                const volData = parseScannerOutput(scannerOutputs['volume']);
                if (volData && volData.length > 0) {
                    analyses.volume = volData;
                }
            }

            if (hasVolume) {
                const volData = parseScannerOutput(scannerOutputs['volume']);
                if (volData && volData.length > 0) {
                    analyses.volume = volData;
                }
            }

            if (Object.keys(analyses).length > 0) {
                renderUnifiedAnalysis(analyses);
                analysisMessage.classList.add('hidden');
                analysisDisplay.classList.remove('hidden');
            } else {
                analysisMessage.textContent = 'Unable to parse scanner data for analysis.';
                analysisMessage.classList.remove('hidden');
                analysisDisplay.classList.add('hidden');
            }
        }

        // Render unified analysis showing all scanners together
        function renderUnifiedAnalysis(analyses) {
            const analysisDisplay = document.getElementById('analysisDisplay');
            
            // Update header summary with analysis data
            updateHeaderSummary(analyses);
            
            // Create new 3-row analysis grid layout (removed summary card since it's now in header)
            let html = '<div class="analysis-grid">';
            
            // Row 1: Final Recommendation (Full Width)
            html += '<div class="analysis-row-recommendation">';
            html += generateOverallRecommendationCardHorizontal(analyses);
            html += '</div>';
            
            // Row 2: Price Chart (Full Width)
            html += '<div class="analysis-row-recommendation">';
            html += generatePriceChartCard(analyses);
            html += '</div>';

            // Row 2b: Volume Chart (Full Width) - generate only if volume data exists
            if (analyses.volume && analyses.volume.length > 0) {
                html += '<div class="analysis-row-recommendation">';
                html += generateVolumeAnalysisCard(analyses.volume);
                html += '</div>';
            }
            
            // Row 3: RSI + MACD
            html += '<div class="analysis-row-1">';
            if (analyses.rsi) {
                html += generateRSIAnalysisTable(analyses.rsi);
            } else {
                html += '<div></div>'; // Empty placeholder
            }
            if (analyses.macd) {
                html += generateProfessionalMACDAnalysis(analyses.macd);
            } else {
                html += '<div></div>'; // Empty placeholder
            }
            html += '</div>';
            
            // Row 4: EMA + DMA
            html += '<div class="analysis-row-2">';
            if (analyses.ema) {
                html += generateEMAAnalysisTable(analyses.ema);
            } else {
                html += '<div></div>'; // Empty placeholder
            }
            if (analyses.dma) {
                html += generateDMAAnalysisTable(analyses.dma);
            } else {
                html += '<div></div>'; // Empty placeholder
            }
            html += '</div>';
            
            html += '</div>';
            
            analysisDisplay.innerHTML = html;
            
            // After DOM injection, render the Volume Analysis mini chart if data exists
            if (analyses.volume && analyses.volume.length > 0) {
                setTimeout(() => {
                    try {
                        // Prefer server-provided chartData.volume; else build from parsed table/output
                        let vData = (window.scannerChartData && scannerChartData.volume) ? scannerChartData.volume : null;
                        if (!vData || !Array.isArray(vData.labels) || vData.labels.length === 0) {
                            // Try to populate from outputs
                            try { ensureVolumeChartDataAvailable(); } catch (e) { console.warn('ensureVolumeChartDataAvailable failed', e); }
                            vData = (window.scannerChartData && scannerChartData.volume) ? scannerChartData.volume : null;
                        }
                        if (!vData || !Array.isArray(vData.labels) || vData.labels.length === 0) {
                            // Build directly from analyses.volume rows as a fallback
                            try { vData = buildVolumeChartDataFromTable(analyses.volume) || null; } catch (e) { console.warn('buildVolumeChartDataFromTable failed', e); }
                        }
                        if (vData && Array.isArray(vData.labels) && vData.labels.length > 0) {
                            renderVolumeCardChart(vData);
                        }
                    } catch (e) {
                        console.warn('Post-inject volume card render failed', e);
                    }
                }, 50);
            }
            
            // Initialize the chart using existing Detail section functionality
            setTimeout(() => {
                console.log('Initializing analysis chart using existing system...');
                const hasRSI = analyses.rsi && Object.keys(analyses.rsi).length > 0;
                const hasEMA = analyses.ema && Object.keys(analyses.ema).length > 0;
                const hasDMA = analyses.dma && Object.keys(analyses.dma).length > 0;
                const hasMacd = analyses.macd && Object.keys(analyses.macd).length > 0;
                
                console.log('Chart data availability:', { 
                    hasRSI, 
                    hasEMA, 
                    hasDMA,
                    hasMacd,
                    rsiData: !!scannerChartData.rsi,
                    emaData: !!scannerChartData.ema,
                    dmaData: !!scannerChartData.dma,
                    macdData: !!scannerChartData.macd
                });
                
                // Auto-switch to first available chart with data
                if (hasRSI && scannerChartData.rsi) {
                    console.log('Loading RSI chart');
                    switchAnalysisChartTab('rsi');
                } else if (hasEMA && scannerChartData.ema) {
                    console.log('Loading EMA chart');
                    switchAnalysisChartTab('ema');
                } else if (hasDMA && scannerChartData.dma) {
                    console.log('Loading DMA chart');
                    switchAnalysisChartTab('dma');
                } else {
                    console.log('No chart data available yet');
                }
            }, 500);
        }

        // Generate final recommendation as a card for the 2x2 grid
        function generateOverallRecommendationCard(analyses) {
            const signals = [];
            
            if (analyses.rsi) {
                // RSI signal logic
                const rsiValues = [];
                Object.keys(analyses.rsi).forEach(key => {
                    if (key.toUpperCase().includes('RSI')) {
                        const rsiValue = parseFloat(analyses.rsi[key]);
                        if (!isNaN(rsiValue)) rsiValues.push(rsiValue);
                    }
                });
                
                const overboughtThreshold = parseInt(document.getElementById('rsiOverbought').value) || 70;
                const oversoldThreshold = parseInt(document.getElementById('rsiOversold').value) || 30;
                const overboughtCount = rsiValues.filter(v => v >= overboughtThreshold).length;
                const oversoldCount = rsiValues.filter(v => v <= oversoldThreshold).length;
                
                if (oversoldCount > overboughtCount) signals.push('BUY');
                else if (overboughtCount > oversoldCount) signals.push('SELL');
                else signals.push('HOLD');
            }
            
            if (analyses.ema) {
                // EMA signal logic
                const ema9 = parseFloat(analyses.ema['EMA9']);
                const ema15 = parseFloat(analyses.ema['EMA15']);
                if (!isNaN(ema9) && !isNaN(ema15)) {
                    if (ema9 > ema15) signals.push('BUY');
                    else signals.push('SELL');
                }
            }
            
            if (analyses.dma) {
                // DMA signal logic
                const cmp = parseFloat(analyses.dma['CMP']) || 0;
                let aboveCount = 0, belowCount = 0;
                Object.keys(analyses.dma).forEach(key => {
                    if (key.toUpperCase().includes('DMA')) {
                        const dmaValue = parseFloat(analyses.dma[key]);
                        if (!isNaN(dmaValue)) {
                            if (cmp > dmaValue) aboveCount++;
                            else belowCount++;
                        }
                    }
                });
                
                if (aboveCount > belowCount) signals.push('BUY');
                else if (belowCount > aboveCount) signals.push('SELL');
                else signals.push('HOLD');
            }
            
            // Overall consensus
            const buyCount = signals.filter(s => s === 'BUY').length;
            const sellCount = signals.filter(s => s === 'SELL').length;
            const holdCount = signals.filter(s => s === 'HOLD').length;
            
            let overallSignal = 'HOLD';
            let signalType = 'neutral';
            let consensus = 'Mixed';
            
            if (buyCount > sellCount && buyCount > holdCount) {
                overallSignal = 'BUY';
                signalType = 'bullish';
                consensus = buyCount === signals.length ? 'Strong' : 'Moderate';
            } else if (sellCount > buyCount && sellCount > holdCount) {
                overallSignal = 'SELL';
                signalType = 'bearish';
                consensus = sellCount === signals.length ? 'Strong' : 'Moderate';
            }

            return `
                <div class="summary-card final-recommendation-card" style="background: linear-gradient(135deg, ${signalType === 'bullish' ? 'rgba(40, 167, 69, 0.1)' : signalType === 'bearish' ? 'rgba(220, 53, 69, 0.1)' : 'rgba(108, 117, 125, 0.1)'} 0%, var(--bg-primary) 100%); border: 2px solid ${signalType === 'bullish' ? 'var(--success)' : signalType === 'bearish' ? 'var(--danger)' : '#6c757d'};">
                    <div class="summary-header">
                        <i class="fas fa-bullseye" style="color: ${signalType === 'bullish' ? 'var(--success)' : signalType === 'bearish' ? 'var(--danger)' : '#6c757d'};"></i>
                        Final Recommendation
                    </div>
                    
                    <div class="final-recommendation-content">
                        <div style="font-size: 2rem; margin-bottom: 1rem;">
                            <i class="fas fa-${signalType === 'bullish' ? 'thumbs-up' : signalType === 'bearish' ? 'thumbs-down' : 'hand-paper'}" style="color: ${signalType === 'bullish' ? 'var(--success)' : signalType === 'bearish' ? 'var(--danger)' : '#6c757d'};"></i>
                        </div>
                        
                        <h3 style="margin: 0 0 0.5rem 0; color: ${signalType === 'bullish' ? 'var(--success)' : signalType === 'bearish' ? 'var(--danger)' : '#6c757d'}; font-size: 1.5rem;">
                            <strong>${overallSignal}</strong>
                        </h3>
                        
                        <div style="font-size: 1rem; margin-bottom: 1rem; color: var(--text-primary);">
                            <strong>${consensus} Consensus</strong>
                        </div>
                        
                        <div style="font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 1rem;">
                            ${buyCount} Buy • ${sellCount} Sell • ${holdCount} Hold
                        </div>
                        
                        <div style="font-size: 1.1rem; font-weight: bold; color: ${signalType === 'bullish' ? 'var(--success)' : signalType === 'bearish' ? 'var(--danger)' : '#6c757d'}; padding: 0.5rem; background: var(--bg-secondary); border-radius: 4px;">
                            ${overallSignal === 'BUY' ? '🎯 EXECUTE LONG' : 
                              overallSignal === 'SELL' ? '🎯 EXECUTE SHORT' : 
                              '🎯 WAIT & WATCH'}
                        </div>
                        
                        <div style="margin-top: 1rem; font-size: 0.8rem; color: var(--text-secondary);">
                            Always use proper risk management
                        </div>
                    </div>
                </div>
            `;
        }

        // Generate RSI Analysis Table
        function generateRSIAnalysisTable(rsiData) {
            const overboughtThreshold = parseInt(document.getElementById('rsiOverbought').value) || 70;
            const oversoldThreshold = parseInt(document.getElementById('rsiOversold').value) || 30;
            
            let rsiRows = [];
            let buySignals = 0;
            let sellSignals = 0;
            let holdSignals = 0;
            
            Object.keys(rsiData).forEach(key => {
                if (key.toUpperCase().includes('RSI')) {
                    const rsiValue = parseFloat(rsiData[key]);
                    if (!isNaN(rsiValue)) {
                        let signal = '';
                        let signalClass = 'neutral';
                        let recommendation = '';
                        
                        if (rsiValue >= overboughtThreshold) {
                            signal = 'SELL';
                            signalClass = 'bearish';
                            recommendation = 'Overbought - Consider selling';
                            sellSignals++;
                        } else if (rsiValue <= oversoldThreshold) {
                            signal = 'BUY';
                            signalClass = 'bullish';
                            recommendation = 'Oversold - Consider buying';
                            buySignals++;
                        } else {
                            signal = 'HOLD';
                            signalClass = 'neutral';
                            recommendation = 'Neutral - Wait for signal';
                            holdSignals++;
                        }

                        rsiRows.push({
                            indicator: key,
                            value: rsiValue.toFixed(2),
                            signal: signal,
                            signalClass: signalClass,
                            recommendation: recommendation
                        });
                    }
                }
            });

            // Determine overall RSI signal
            let overallSignal = 'Wait for Clear Signal';
            let signalType = 'neutral';
            
            if (buySignals > sellSignals && buySignals > holdSignals) {
                overallSignal = buySignals === rsiRows.length ? 'Strong Buy Signal' : 'Bullish Momentum';
                signalType = 'bullish';
            } else if (sellSignals > buySignals && sellSignals > holdSignals) {
                overallSignal = sellSignals === rsiRows.length ? 'Strong Sell Signal' : 'Bearish Pressure';
                signalType = 'bearish';
            } else {
                overallSignal = 'Mixed RSI Signals';
                signalType = 'neutral';
            }

            return `
                <div class="summary-card" style="border-left: 4px solid ${signalType === 'bullish' ? 'var(--success)' : signalType === 'bearish' ? 'var(--danger)' : '#6c757d'};">
                    <div class="summary-header">
                        <i class="fas fa-chart-line" style="color: ${signalType === 'bullish' ? 'var(--success)' : signalType === 'bearish' ? 'var(--danger)' : '#6c757d'};"></i>
                        RSI Analysis
                    </div>
                    
                    <div style="text-align: center; margin: 1rem 0; padding: 0.75rem; background: ${signalType === 'bullish' ? 'rgba(40, 167, 69, 0.1)' : signalType === 'bearish' ? 'rgba(220, 53, 69, 0.1)' : 'rgba(108, 117, 125, 0.1)'}; border-radius: 6px;">
                        <div style="font-size: 1.1rem; font-weight: 600; color: ${signalType === 'bullish' ? 'var(--success)' : signalType === 'bearish' ? 'var(--danger)' : '#6c757d'};">
                            <i class="fas fa-${signalType === 'bullish' ? 'arrow-up' : signalType === 'bearish' ? 'arrow-down' : 'minus'}"></i> ${overallSignal}
                        </div>
                        <div style="font-size: 0.9rem; color: var(--text-secondary); margin-top: 0.25rem;">
                            ${buySignals} Buy • ${sellSignals} Sell • ${holdSignals} Hold
                        </div>
                    </div>
                    
                    <div class="table-container analysis-table" style="margin-top: 1rem;">
                        <table class="table" style="margin-bottom: 0;">
                            <thead>
                                <tr>
                                    <th style="width: 25%;">Indicator</th>
                                    <th style="width: 20%;">Value</th>
                                    <th style="width: 20%;">Signal</th>
                                    <th style="width: 35%;">Recommendation</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${rsiRows.map(row => `
                                    <tr>
                                        <td>${row.indicator}</td>
                                        <td><strong>${row.value}</strong></td>
                                        <td>
                                            <span class="signal-item ${row.signalClass}">
                                                <i class="fas fa-${row.signalClass === 'bullish' ? 'arrow-up' : row.signalClass === 'bearish' ? 'arrow-down' : 'minus'}" style="margin-right: 0.25rem; font-size: 0.7rem;"></i>
                                                ${row.signal}
                                            </span>
                                        </td>
                                        <td>${row.recommendation}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
        }

        // Generate EMA Analysis Table
        function generateEMAAnalysisTable(emaData) {
            const emaValues = {};
            Object.keys(emaData).forEach(key => {
                if (key.toUpperCase().includes('EMA')) {
                    const emaValue = parseFloat(emaData[key]);
                    if (!isNaN(emaValue)) {
                        emaValues[key] = emaValue;
                    }
                }
            });

            const ema9Value = emaValues['EMA9'];
            const ema15Value = emaValues['EMA15'];
            const cmp = parseFloat(emaData['CMP']) || 0;
            
            let emaRows = [];
            let buySignals = 0;
            let sellSignals = 0;
            
            Object.keys(emaValues).forEach(key => {
                let signal = 'HOLD';
                let signalClass = 'neutral';
                let recommendation = '';
                
                if (key === 'EMA9' && ema9Value && ema15Value) {
                    if (ema9Value > ema15Value) {
                        signal = 'BUY';
                        signalClass = 'bullish';
                        recommendation = 'Above EMA15 - Bullish crossover';
                        buySignals++;
                    } else {
                        signal = 'SELL';
                        signalClass = 'bearish';
                        recommendation = 'Below EMA15 - Bearish crossover';
                        sellSignals++;
                    }
                } else {
                    if (cmp > emaValues[key]) {
                        signal = 'BUY';
                        signalClass = 'bullish';
                        recommendation = 'Price above EMA - Acting as support';
                        buySignals++;
                    } else {
                        signal = 'SELL';
                        signalClass = 'bearish';
                        recommendation = 'Price below EMA - Acting as resistance';
                        sellSignals++;
                    }
                }

                emaRows.push({
                    indicator: key,
                    value: emaValues[key].toFixed(2),
                    signal: signal,
                    signalClass: signalClass,
                    recommendation: recommendation
                });
            });

            // Determine overall EMA signal
            let overallSignal = 'Sideways Movement';
            let signalType = 'neutral';
            
            if (buySignals > sellSignals) {
                overallSignal = buySignals === emaRows.length ? 'Strong Bullish Momentum' : 'Bullish Momentum';
                signalType = 'bullish';
            } else if (sellSignals > buySignals) {
                overallSignal = sellSignals === emaRows.length ? 'Strong Bearish Momentum' : 'Bearish Momentum';
                signalType = 'bearish';
            } else {
                overallSignal = 'Mixed EMA Signals';
                signalType = 'neutral';
            }

            return `
                <div class="summary-card" style="border-left: 4px solid ${signalType === 'bullish' ? 'var(--success)' : signalType === 'bearish' ? 'var(--danger)' : '#6c757d'};">
                    <div class="summary-header">
                        <i class="fas fa-exchange-alt" style="color: ${signalType === 'bullish' ? 'var(--success)' : signalType === 'bearish' ? 'var(--danger)' : '#6c757d'};"></i>
                        EMA Analysis
                    </div>
                    
                    <div style="text-align: center; margin: 1rem 0; padding: 0.75rem; background: ${signalType === 'bullish' ? 'rgba(40, 167, 69, 0.1)' : signalType === 'bearish' ? 'rgba(220, 53, 69, 0.1)' : 'rgba(108, 117, 125, 0.1)'}; border-radius: 6px;">
                        <div style="font-size: 1.1rem; font-weight: 600; color: ${signalType === 'bullish' ? 'var(--success)' : signalType === 'bearish' ? 'var(--danger)' : '#6c757d'};">
                            <i class="fas fa-${signalType === 'bullish' ? 'trending-up' : signalType === 'bearish' ? 'trending-down' : 'minus'}"></i> ${overallSignal}
                        </div>
                        <div style="font-size: 0.9rem; color: var(--text-secondary); margin-top: 0.25rem;">
                            ${buySignals} Bullish • ${sellSignals} Bearish
                        </div>
                    </div>
                    
                    <div class="table-container analysis-table" style="margin-top: 1rem;">
                        <table class="table" style="margin-bottom: 0;">
                            <thead>
                                <tr>
                                    <th style="width: 25%;">Indicator</th>
                                    <th style="width: 20%;">Value</th>
                                    <th style="width: 20%;">Signal</th>
                                    <th style="width: 35%;">Recommendation</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${emaRows.map(row => `
                                    <tr>
                                        <td>${row.indicator}</td>
                                        <td><strong>${row.value}</strong></td>
                                        <td>
                                            <span class="signal-item ${row.signalClass}">
                                                <i class="fas fa-${row.signalClass === 'bullish' ? 'arrow-up' : row.signalClass === 'bearish' ? 'arrow-down' : 'minus'}" style="margin-right: 0.25rem; font-size: 0.7rem;"></i>
                                                ${row.signal}
                                            </span>
                                        </td>
                                        <td>${row.recommendation}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
        }

        // Generate DMA Analysis Table
        function generateDMAAnalysisTable(dmaData) {
            const cmp = parseFloat(dmaData['CMP']) || 0;
            
            let dmaRows = [];
            let aboveCount = 0;
            let belowCount = 0;
            
            Object.keys(dmaData).forEach(key => {
                if (key.toUpperCase().includes('DMA')) {
                    const dmaValue = parseFloat(dmaData[key]);
                    if (!isNaN(dmaValue) && cmp > 0) {
                        const percentDiff = ((cmp - dmaValue) / dmaValue) * 100;
                        
                        let signal = '';
                        let signalClass = 'neutral';
                        let recommendation = '';
                        
                        if (cmp > dmaValue) {
                            signal = 'BUY';
                            signalClass = 'bullish';
                            recommendation = 'Above DMA - Acting as support level';
                            aboveCount++;
                        } else {
                            signal = 'SELL';
                            signalClass = 'bearish';
                            recommendation = 'Below DMA - Acting as resistance level';
                            belowCount++;
                        }

                        dmaRows.push({
                            indicator: key,
                            value: dmaValue.toFixed(2) + ' (' + (percentDiff > 0 ? '+' : '') + percentDiff.toFixed(2) + '%)',
                            signal: signal,
                            signalClass: signalClass,
                            recommendation: recommendation
                        });
                    }
                }
            });

            // Determine overall DMA signal
            let overallSignal = 'Mixed Levels';
            let signalType = 'neutral';
            
            if (aboveCount > belowCount) {
                overallSignal = aboveCount === dmaRows.length ? 'Strong Support Levels' : 'Mostly Supported';
                signalType = 'bullish';
            } else if (belowCount > aboveCount) {
                overallSignal = belowCount === dmaRows.length ? 'Facing Strong Resistance' : 'Mostly Resistance';
                signalType = 'bearish';
            } else {
                overallSignal = 'Mixed Support/Resistance';
                signalType = 'neutral';
            }

            return `
                <div class="summary-card" style="border-left: 4px solid ${signalType === 'bullish' ? 'var(--success)' : signalType === 'bearish' ? 'var(--danger)' : '#6c757d'};">
                    <div class="summary-header">
                        <i class="fas fa-chart-bar" style="color: ${signalType === 'bullish' ? 'var(--success)' : signalType === 'bearish' ? 'var(--danger)' : '#6c757d'};"></i>
                        DMA Analysis
                    </div>
                    
                    <div style="text-align: center; margin: 1rem 0; padding: 0.75rem; background: ${signalType === 'bullish' ? 'rgba(40, 167, 69, 0.1)' : signalType === 'bearish' ? 'rgba(220, 53, 69, 0.1)' : 'rgba(108, 117, 125, 0.1)'}; border-radius: 6px;">
                        <div style="font-size: 1.1rem; font-weight: 600; color: ${signalType === 'bullish' ? 'var(--success)' : signalType === 'bearish' ? 'var(--danger)' : '#6c757d'};">
                            <i class="fas fa-${signalType === 'bullish' ? 'shield-alt' : signalType === 'bearish' ? 'exclamation-triangle' : 'balance-scale'}"></i> ${overallSignal}
                        </div>
                        <div style="font-size: 0.9rem; color: var(--text-secondary); margin-top: 0.25rem;">
                            ${aboveCount} Above • ${belowCount} Below DMA
                        </div>
                    </div>
                    
                    <div class="table-container analysis-table" style="margin-top: 1rem;">
                        <table class="table" style="margin-bottom: 0;">
                            <thead>
                                <tr>
                                    <th style="width: 25%;">Indicator</th>
                                    <th style="width: 30%;">Value (% Diff)</th>
                                    <th style="width: 20%;">Signal</th>
                                    <th style="width: 25%;">Level Type</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${dmaRows.map(row => `
                                    <tr>
                                        <td>${row.indicator}</td>
                                        <td><strong>${row.value}</strong></td>
                                        <td>
                                            <span class="signal-item ${row.signalClass}">
                                                <i class="fas fa-${row.signalClass === 'bullish' ? 'arrow-up' : 'arrow-down'}" style="margin-right: 0.25rem; font-size: 0.7rem;"></i>
                                                ${row.signal}
                                            </span>
                                        </td>
                                        <td>${row.recommendation.includes('support') ? 'Support' : 'Resistance'}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
        }

        // Generate Volume Analysis Card (full width)
        function generateVolumeAnalysisCard(volumeRows) {
            if (!volumeRows || volumeRows.length === 0) {
                return '<div></div>';
            }

            // Use latest row (last in array is often most recent depending on parsing)
            const latest = volumeRows[volumeRows.length - 1] || volumeRows[0];
            const symbol = latest['Symbol'] || latest['symbol'] || '';
            const time = latest['Time'] || latest['time'] || '';
            const cmp = latest['CMP'] || latest['cmp'] || '';
            const vol = latest['Volume'] || latest['volume'] || latest['Vol'] || latest['vol'] || '';
            const avg = latest['AvgVolume'] || latest['avgVolume'] || latest['avg'] || '';
            const ratio = latest['VolRatio'] || latest['vol_ratio'] || latest['volRatio'] || '';
            const status = latest['Status'] || latest['status'] || '';

            return `
                <div class="analysis-card" style="border: 1px solid var(--border-color);">
                    <div class="mb-2" style="display:flex; justify-content:space-between; align-items:center; padding: 0.75rem 1rem;">
                        <h4 style="margin:0;"><i class="fas fa-chart-area"></i> Volume Analysis</h4>
                        <div style="font-size:0.9rem; color:var(--text-secondary);">${symbol} &nbsp; <small>${time}</small></div>
                    </div>
                    <div style="padding: 0 1rem 1rem 1rem;">
                        <div style="display:flex; gap:1.25rem; align-items:center; margin-bottom:0.5rem;">
                            <div><strong>CMP:</strong> ${cmp}</div>
                            <div><strong>Vol:</strong> ${formatNumberForDisplay(vol)}</div>
                            <div><strong>Avg:</strong> ${formatNumberForDisplay(avg)}</div>
                            <div><strong>Ratio:</strong> ${ratio}</div>
                            <div><strong>Status:</strong> ${status}</div>
                        </div>

                        <div style="height:140px;">
                            <canvas id="volumeCardChart" width="400" height="140"></canvas>
                        </div>

                        <div style="margin-top:0.5rem; font-size:0.85rem; color:var(--text-secondary);">Last ${Math.min(volumeRows.length,60)} bars • Spike threshold from config</div>
                    </div>
                </div>
            `;
        }

        // Render small volume chart inside the Volume Analysis Card
        function renderVolumeCardChart(volumeChartData) {
            if (!volumeChartData || !Array.isArray(volumeChartData.labels)) return;
            const canvas = document.getElementById('volumeCardChart');
            if (!canvas) return;

            try {
                const ctx = canvas.getContext('2d');
                if (canvas._chartInstance) { canvas._chartInstance.destroy(); }

                const labels = volumeChartData.labels.slice(-60);
                const volumes = (volumeChartData.volumes || []).slice(-60);
                const avg = (volumeChartData.avgVolumes || []).slice(-60);

                const small = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [
                            { label: 'Volume', data: volumes, backgroundColor: volumes.map(v => v > 0 ? 'rgba(59,130,246,0.7)' : 'rgba(108,117,125,0.5)') },
                            { label: 'Avg', data: avg, type: 'line', borderColor: 'rgba(34,197,94,0.9)', fill: false, pointRadius: 0, tension: 0.1 }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: { x: { display: false }, y: { display: true } },
                        plugins: { legend: { display: false } }
                    }
                });

                canvas._chartInstance = small;
            } catch (e) {
                console.warn('renderVolumeCardChart failed', e);
            }
        }

        // Generate analysis table showing all indicators
        function generateAnalysisTable(analyses) {
            const overboughtThreshold = parseInt(document.getElementById('rsiOverbought').value) || 70;
            const oversoldThreshold = parseInt(document.getElementById('rsiOversold').value) || 30;
            
            let tableRows = [];
            
            // RSI Analysis Rows
            if (analyses.rsi) {
                Object.keys(analyses.rsi).forEach(key => {
                    if (key.toUpperCase().includes('RSI')) {
                        const rsiValue = parseFloat(analyses.rsi[key]);
                        if (!isNaN(rsiValue)) {
                            let signal = '';
                            let signalClass = 'neutral';
                            let recommendation = '';
                            
                            if (rsiValue >= overboughtThreshold) {
                                signal = 'SELL';
                                signalClass = 'bearish';
                                recommendation = 'Overbought - Consider selling';
                            } else if (rsiValue <= oversoldThreshold) {
                                signal = 'BUY';
                                signalClass = 'bullish';
                                recommendation = 'Oversold - Consider buying';
                            } else {
                                signal = 'HOLD';
                                signalClass = 'neutral';
                                recommendation = 'Neutral zone - Wait';
                            }

                            tableRows.push({
                                category: 'RSI',
                                indicator: key,
                                value: rsiValue.toFixed(2),
                                signal: signal,
                                signalClass: signalClass,
                                recommendation: recommendation
                            });
                        }
                    }
                });
            }
            
            // EMA Analysis Rows
            if (analyses.ema) {
                const emaValues = {};
                Object.keys(analyses.ema).forEach(key => {
                    if (key.toUpperCase().includes('EMA')) {
                        const emaValue = parseFloat(analyses.ema[key]);
                        if (!isNaN(emaValue)) {
                            emaValues[key] = emaValue;
                        }
                    }
                });

                const ema9Value = emaValues['EMA9'];
                const ema15Value = emaValues['EMA15'];
                const cmp = parseFloat(analyses.ema['CMP']) || 0;
                
                Object.keys(emaValues).forEach(key => {
                    let signal = 'HOLD';
                    let signalClass = 'neutral';
                    let recommendation = '';
                    
                    if (key === 'EMA9' && ema9Value && ema15Value) {
                        if (ema9Value > ema15Value) {
                            signal = 'BUY';
                            signalClass = 'bullish';
                            recommendation = 'Above EMA15 - Bullish trend';
                        } else {
                            signal = 'SELL';
                            signalClass = 'bearish';
                            recommendation = 'Below EMA15 - Bearish trend';
                        }
                    } else {
                        if (cmp > emaValues[key]) {
                            signal = 'BUY';
                            signalClass = 'bullish';
                            recommendation = 'Price above EMA - Support';
                        } else {
                            signal = 'SELL';
                            signalClass = 'bearish';
                            recommendation = 'Price below EMA - Resistance';
                        }
                    }

                    tableRows.push({
                        category: 'EMA',
                        indicator: key,
                        value: emaValues[key].toFixed(2),
                        signal: signal,
                        signalClass: signalClass,
                        recommendation: recommendation
                    });
                });
            }
            
            // DMA Analysis Rows
            if (analyses.dma) {
                const cmp = parseFloat(analyses.dma['CMP']) || 0;
                
                Object.keys(analyses.dma).forEach(key => {
                    if (key.toUpperCase().includes('DMA')) {
                        const dmaValue = parseFloat(analyses.dma[key]);
                        if (!isNaN(dmaValue) && cmp > 0) {
                            const percentDiff = ((cmp - dmaValue) / dmaValue) * 100;
                            
                            let signal = '';
                            let signalClass = 'neutral';
                            let recommendation = '';
                            
                            if (cmp > dmaValue) {
                                signal = 'BUY';
                                signalClass = 'bullish';
                                recommendation = 'Above DMA - Support level';
                            } else {
                                signal = 'SELL';
                                signalClass = 'bearish';
                                recommendation = 'Below DMA - Resistance level';
                            }

                            tableRows.push({
                                category: 'DMA',
                                indicator: key,
                                value: dmaValue.toFixed(2) + ' (' + (percentDiff > 0 ? '+' : '') + percentDiff.toFixed(2) + '%)',
                                signal: signal,
                                signalClass: signalClass,
                                recommendation: recommendation
                            });
                        }
                    }
                });
            }

            if (tableRows.length === 0) {
                return '<div class="text-center" style="padding: 2rem;">No analysis data available</div>';
            }

            return `
                <div class="summary-card">
                    <div class="summary-header">
                        <i class="fas fa-table"></i>
                        Technical Analysis Summary
                    </div>
                    
                    <div class="table-container analysis-table" style="margin-top: 1rem;">
                        <table class="table" style="margin-bottom: 0;">
                            <thead>
                                <tr>
                                    <th style="width: 12%;">Category</th>
                                    <th style="width: 18%;">Indicator</th>
                                    <th style="width: 20%;">Current Value</th>
                                    <th style="width: 15%;">Signal</th>
                                    <th style="width: 35%;">Recommendation</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${tableRows.map(row => `
                                    <tr>
                                        <td>${row.category}</td>
                                        <td>${row.indicator}</td>
                                        <td>${row.value}</td>
                                        <td>
                                            <span class="signal-item ${row.signalClass}">
                                                <i class="fas fa-${row.signalClass === 'bullish' ? 'arrow-up' : row.signalClass === 'bearish' ? 'arrow-down' : 'minus'}" style="margin-right: 0.25rem; font-size: 0.7rem;"></i>
                                                ${row.signal}
                                            </span>
                                        </td>
                                        <td>${row.recommendation}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
        }

        // Generate professional RSI analysis using exact table values
        function generateProfessionalRSIAnalysis(latestData) {
            const symbol = latestData['Symbol'] || 'N/A';
            const cmp = parseFloat(latestData['CMP']) || 0;
            const overboughtThreshold = parseInt(document.getElementById('rsiOverbought').value) || 70;
            const oversoldThreshold = parseInt(document.getElementById('rsiOversold').value) || 30;

            let signals = [];
            let overallSignal = 'HOLD';
            let signalType = 'neutral';

            // Use exact RSI values from table data
            Object.keys(latestData).forEach(key => {
                if (key.toUpperCase().includes('RSI')) {
                    const rsiValue = parseFloat(latestData[key]);
                    if (!isNaN(rsiValue)) {
                        let signal = '';
                        let type = 'neutral';
                        
                        if (rsiValue >= overboughtThreshold) {
                            signal = 'SELL';
                            type = 'bearish';
                        } else if (rsiValue <= oversoldThreshold) {
                            signal = 'BUY';
                            type = 'bullish';
                        } else {
                            signal = 'HOLD';
                            type = 'neutral';
                        }

                        signals.push({
                            indicator: key,
                            value: rsiValue,
                            signal: signal,
                            type: type
                        });
                    }
                }
            });

            // Determine overall signal
            const buySignals = signals.filter(s => s.signal === 'BUY').length;
            const sellSignals = signals.filter(s => s.signal === 'SELL').length;
            
            if (buySignals > sellSignals) {
                overallSignal = 'BUY';
                signalType = 'bullish';
            } else if (sellSignals > buySignals) {
                overallSignal = 'SELL';
                signalType = 'bearish';
            }

            return `
                <div class="summary-card" style="border-left: 4px solid ${signalType === 'bullish' ? 'var(--success)' : signalType === 'bearish' ? 'var(--danger)' : '#6c757d'};">
                    <div class="summary-header">
                        <i class="fas fa-chart-line" style="color: ${signalType === 'bullish' ? 'var(--success)' : signalType === 'bearish' ? 'var(--danger)' : '#6c757d'};"></i>
                        RSI Analysis
                    </div>
                    
                    <div class="signal-item ${signalType}" style="margin-bottom: 1rem; font-size: 1.1rem; justify-content: center;">
                        <i class="fas fa-${signalType === 'bullish' ? 'arrow-up' : signalType === 'bearish' ? 'arrow-down' : 'minus'} signal-icon"></i>
                        <div class="signal-text"><strong>${overallSignal} SIGNAL</strong></div>
                    </div>

                    <div class="signal-grid">
                        ${signals.map(signal => `
                            <div class="signal-item ${signal.type}">
                                <i class="fas fa-circle signal-icon" style="font-size: 0.5rem;"></i>
                                <div>
                                    <div class="signal-text">${signal.indicator}</div>
                                    <div class="signal-value">${signal.value.toFixed(2)} → ${signal.signal}</div>
                                </div>
                            </div>
                        `).join('')}
                    </div>

                    <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border-color); font-size: 0.9rem; text-align: center;">
                        <strong style="color: ${signalType === 'bullish' ? 'var(--success)' : signalType === 'bearish' ? 'var(--danger)' : 'var(--text-secondary)'};">
                            ${overallSignal === 'BUY' ? '📈 Consider Long Position' : 
                              overallSignal === 'SELL' ? '📉 Consider Short Position' : 
                              '⏸️ Wait for Clear Signal'}
                        </strong>
                    </div>
                </div>
            `;
        }

        // Generate professional EMA analysis using exact table values
        function generateProfessionalEMAAnalysis(latestData) {
            const symbol = latestData['Symbol'] || 'N/A';
            const cmp = parseFloat(latestData['CMP']) || 0;

            // Use exact EMA values from table data
            const emaValues = {};
            Object.keys(latestData).forEach(key => {
                if (key.toUpperCase().includes('EMA')) {
                    const emaValue = parseFloat(latestData[key]);
                    if (!isNaN(emaValue)) {
                        emaValues[key] = emaValue;
                    }
                }
            });

            const ema9Value = emaValues['EMA9'];
            const ema15Value = emaValues['EMA15'];
            
            let overallSignal = 'HOLD';
            let signalType = 'neutral';
            
            if (ema9Value && ema15Value) {
                if (ema9Value > ema15Value) {
                    overallSignal = 'BUY';
                    signalType = 'bullish';
                } else {
                    overallSignal = 'SELL';
                    signalType = 'bearish';
                }
            }

            const priceTrend = ema9Value && cmp > ema9Value ? 'above' : ema9Value && cmp < ema9Value ? 'below' : 'at';
            
            return `
                <div class="summary-card" style="border-left: 4px solid ${signalType === 'bullish' ? 'var(--success)' : signalType === 'bearish' ? 'var(--danger)' : '#6c757d'};">
                    <div class="summary-header">
                        <i class="fas fa-exchange-alt" style="color: ${signalType === 'bullish' ? 'var(--success)' : signalType === 'bearish' ? 'var(--danger)' : '#6c757d'};"></i>
                        EMA Crossover Analysis
                    </div>
                    
                    <div class="signal-item ${signalType}" style="margin-bottom: 1rem; font-size: 1.1rem; justify-content: center;">
                        <i class="fas fa-${signalType === 'bullish' ? 'trending-up' : signalType === 'bearish' ? 'trending-down' : 'minus'} signal-icon"></i>
                        <div class="signal-text"><strong>${overallSignal} SIGNAL</strong></div>
                    </div>

                    <div class="signal-grid">
                        ${Object.keys(emaValues).map(key => `
                            <div class="signal-item ${signalType}">
                                <i class="fas fa-circle signal-icon" style="font-size: 0.5rem;"></i>
                                <div>
                                    <div class="signal-text">${key}</div>
                                    <div class="signal-value">${emaValues[key].toFixed(2)}</div>
                                </div>
                            </div>
                        `).join('')}
                        
                        ${ema9Value ? `
                            <div class="signal-item ${cmp > ema9Value ? 'bullish' : cmp < ema9Value ? 'bearish' : 'neutral'}" style="grid-column: 1 / -1;">
                                <i class="fas fa-${cmp > ema9Value ? 'arrow-up' : cmp < ema9Value ? 'arrow-down' : 'minus'} signal-icon"></i>
                                <div class="signal-text">Price is <strong>${priceTrend}</strong> EMA9</div>
                            </div>
                        ` : ''}
                    </div>

                    <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border-color); font-size: 0.9rem; text-align: center;">
                        <strong style="color: ${signalType === 'bullish' ? 'var(--success)' : signalType === 'bearish' ? 'var(--danger)' : 'var(--text-secondary)'};">
                            ${overallSignal === 'BUY' ? '🚀 Bullish Momentum' : 
                              overallSignal === 'SELL' ? '⬇️ Bearish Momentum' : 
                              '➡️ Sideways Movement'}
                        </strong>
                    </div>
                </div>
            `;
        }

        // Generate professional DMA analysis using exact table values
        function generateProfessionalDMAAnalysis(latestData) {
            const symbol = latestData['Symbol'] || 'N/A';
            const cmp = parseFloat(latestData['CMP']) || 0;

            // Use exact DMA values from table data
            let dmaSignals = [];
            
            Object.keys(latestData).forEach(key => {
                if (key.toUpperCase().includes('DMA')) {
                    const dmaValue = parseFloat(latestData[key]);
                    if (!isNaN(dmaValue) && cmp > 0) {
                        const difference = cmp - dmaValue;
                        const percentDiff = (difference / dmaValue) * 100;
                        
                        let signal = '';
                        let type = 'neutral';
                        
                        if (cmp > dmaValue) {
                            signal = 'SUPPORT';
                            type = 'bullish';
                        } else {
                            signal = 'RESISTANCE';
                            type = 'bearish';
                        }

                        dmaSignals.push({
                            indicator: key,
                            value: dmaValue,
                            percentDiff: percentDiff,
                            signal: signal,
                            type: type
                        });
                    }
                }
            });

            // Determine overall signal
            const supportSignals = dmaSignals.filter(s => s.type === 'bullish').length;
            const resistanceSignals = dmaSignals.filter(s => s.type === 'bearish').length;
            
            let overallSignal = 'HOLD';
            let signalType = 'neutral';
            
            if (supportSignals > resistanceSignals) {
                overallSignal = 'BUY';
                signalType = 'bullish';
            } else if (resistanceSignals > supportSignals) {
                overallSignal = 'SELL';
                signalType = 'bearish';
            }

            return `
                <div class="summary-card" style="border-left: 4px solid ${signalType === 'bullish' ? 'var(--success)' : signalType === 'bearish' ? 'var(--danger)' : '#6c757d'};">
                    <div class="summary-header">
                        <i class="fas fa-chart-bar" style="color: ${signalType === 'bullish' ? 'var(--success)' : signalType === 'bearish' ? 'var(--danger)' : '#6c757d'};"></i>
                        DMA Support/Resistance
                    </div>
                    
                    <div class="signal-item ${signalType}" style="margin-bottom: 1rem; font-size: 1.1rem; justify-content: center;">
                        <i class="fas fa-${signalType === 'bullish' ? 'shield-alt' : signalType === 'bearish' ? 'exclamation-triangle' : 'minus'} signal-icon"></i>
                        <div class="signal-text"><strong>${overallSignal} SIGNAL</strong></div>
                    </div>

                    <div class="signal-grid">
                        ${dmaSignals.map(signal => `
                            <div class="signal-item ${signal.type}">
                                <i class="fas fa-circle signal-icon" style="font-size: 0.5rem;"></i>
                                <div>
                                    <div class="signal-text">${signal.indicator}</div>
                                    <div class="signal-value">${signal.value.toFixed(2)} (${signal.percentDiff > 0 ? '+' : ''}${signal.percentDiff.toFixed(2)}%)</div>
                                </div>
                            </div>
                        `).join('')}
                    </div>

                    <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border-color); font-size: 0.9rem; text-align: center;">
                        <strong style="color: ${signalType === 'bullish' ? 'var(--success)' : signalType === 'bearish' ? 'var(--danger)' : 'var(--text-secondary)'};">
                            ${overallSignal === 'BUY' ? '🛡️ Strong Support Levels' : 
                              overallSignal === 'SELL' ? '🚧 Facing Resistance' : 
                              '⚖️ Mixed Levels'}
                        </strong>
                    </div>
                </div>
            `;
        }

        // Generate professional MACD analysis using exact table values
        function generateProfessionalMACDAnalysis(macdData) {
            if (!Array.isArray(macdData) || macdData.length === 0) {
                return '<div class="summary-card"><div class="summary-header"><i class="fas fa-wave-square"></i> MACD Analysis</div><div class="text-center muted-text">No MACD data available</div></div>';
            }

            // Sort data in descending order by Time and pick the latest for summary
            const sortedData = [...macdData].sort((a, b) => {
                const dateA = new Date(a.Time || a.time || '1970-01-01');
                const dateB = new Date(b.Time || b.time || '1970-01-01');
                return dateB - dateA; // Descending order
            });

            const latestData = sortedData[0];
            const symbol = latestData['Symbol'] || latestData['symbol'] || 'N/A';
            const cmp = parseFloat(latestData['CMP'] || latestData['cmp']) || 0;
            const macd = parseFloat(latestData['MACD'] || latestData['macd']) || 0;
            const signal = parseFloat(latestData['Signal'] || latestData['signal']) || 0;
            const histogram = parseFloat(latestData['Histogram'] || latestData['histogram']) || 0;
            const status = latestData['Status'] || latestData['status'] || 'Unknown';

            // Determine signal strength and type (simple heuristics)
            let overallSignal = 'HOLD';
            let signalType = 'neutral';
            let signalStrength = 'Weak';
            if (macd > signal && histogram > 0) { overallSignal = 'BUY'; signalType = 'bullish'; signalStrength = Math.abs(histogram) > 10 ? 'Strong' : 'Moderate'; }
            else if (macd < signal && histogram < 0) { overallSignal = 'SELL'; signalType = 'bearish'; signalStrength = Math.abs(histogram) > 10 ? 'Strong' : 'Moderate'; }

            let trendDirection = macd > signal ? '📈 Uptrend' : macd < signal ? '📉 Downtrend' : '➡️ Sideways';

            // Prepare data for vertical histogram + MACD/Signal overlay (last 40 points)
            const chartData = sortedData.slice(0, 40).reverse(); // chronological order
            const chartLabels = chartData.map(item => (item.Time || item.time || '').replace('T', ' ').replace(/:\d{2}Z?$/,'') || '');
            const histogramValues = chartData.map(item => parseFloat(item.Histogram || item.histogram) || 0);
            const macdValues = chartData.map(item => parseFloat(item.MACD || item.macd) || 0);
            const signalValues = chartData.map(item => parseFloat(item.Signal || item.signal) || 0);

            // Determine symmetric y-axis range so zero is centered
            const allAbs = histogramValues.concat(macdValues).concat(signalValues).map(Math.abs);
            const maxAbs = Math.max(1, ...(allAbs.length ? allAbs : [1]));
            const yLimit = Math.ceil(maxAbs * 1.1 * 10000) / 10000; // small padding

            // Colors for histogram bars
            const barColors = histogramValues.map(v => v > 0 ? 'rgba(40,167,69,0.8)' : v < 0 ? 'rgba(220,53,69,0.8)' : 'rgba(108,117,125,0.7)');

            const borderColor = signalType === 'bullish' ? 'var(--success)' : signalType === 'bearish' ? 'var(--danger)' : '#6c757d';
            const headerColor = signalType === 'bullish' ? 'var(--success)' : signalType === 'bearish' ? 'var(--danger)' : '#6c757d';
            const macdColor = macd > signal ? 'var(--success)' : 'var(--danger)';
            const signalColor = 'rgba(255, 193, 7, 1)';
            const histogramColor = histogram > 0 ? 'var(--success)' : histogram < 0 ? 'var(--danger)' : '#6c757d';
            const trendColor = signalType === 'bullish' ? 'var(--success)' : signalType === 'bearish' ? 'var(--danger)' : 'var(--text-secondary)';

            const signalIcon = signalType === 'bullish' ? 'arrow-up' : signalType === 'bearish' ? 'arrow-down' : 'arrows-alt-h';

            // Build the HTML summary card with a canvas for the combined chart
            const html = '<div class="summary-card" style="border-left: 4px solid ' + borderColor + ';">' +
                '<div class="summary-header">' +
                    '<i class="fas fa-wave-square" style="color: ' + headerColor + ';"></i> MACD Momentum Analysis' +
                '</div>' +

                '<div class="signal-item ' + signalType + '" style="margin-bottom: 1rem; font-size: 1.1rem; justify-content: center;">' +
                    '<i class="fas fa-' + signalIcon + ' signal-icon"></i>' +
                    '<div class="signal-text"><strong>' + overallSignal + ' SIGNAL</strong></div>' +
                '</div>' +

                '<div class="signal-grid">' +
                    '<div class="signal-item">' +
                        '<i class="fas fa-chart-line signal-icon"></i>' +
                        '<div>' +
                            '<div class="signal-text">MACD Line</div>' +
                            '<div class="signal-value" style="color: ' + macdColor + ';">' + macd.toFixed(4) + '</div>' +
                        '</div>' +
                    '</div>' +
                    '<div class="signal-item">' +
                        '<i class="fas fa-signal signal-icon"></i>' +
                        '<div>' +
                            '<div class="signal-text">Signal Line</div>' +
                            '<div class="signal-value" style="color: ' + signalColor + ';">' + signal.toFixed(4) + '</div>' +
                        '</div>' +
                    '</div>' +
                    '<div class="signal-item ' + signalType + '">' +
                        '<i class="fas fa-chart-bar signal-icon"></i>' +
                        '<div>' +
                            '<div class="signal-text">Histogram</div>' +
                            '<div class="signal-value" style="color: ' + histogramColor + ';">' + histogram.toFixed(4) + '</div>' +
                        '</div>' +
                    '</div>' +
                    '<div class="signal-item">' +
                        '<i class="fas fa-compass signal-icon"></i>' +
                        '<div>' +
                            '<div class="signal-text">Status</div>' +
                            '<div class="signal-value">' + status + '</div>' +
                        '</div>' +
                    '</div>' +
                '</div>' +

                '<div style="margin: 1.2rem 0;">' +
                    '<h5 style="margin-bottom: 0.5rem; font-size: 0.9rem; color: var(--text-secondary);">' +
                        '<i class="fas fa-chart-bar"></i> MACD Histogram & Lines (Last ' + chartLabels.length + ' points)' +
                    '</h5>' +
                    '<div style="height:180px;">' +
                        '<canvas id="macdMomentumChart" width="600" height="180"></canvas>' +
                    '</div>' +
                '</div>' +

                '<div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border-color); font-size: 0.9rem; text-align: center;">' +
                    '<strong style="color: ' + trendColor + ';">' +
                        trendDirection + ' - ' + signalStrength + ' Momentum' +
                    '</strong>' +
                '</div>' +
            '</div>';

            // Initialize Chart.js chart after inserting HTML into DOM
            const initScript = '<script>' +
                'setTimeout(() => {' +
                    'const ctx = document.getElementById("macdMomentumChart");' +
                    'if (!ctx || typeof Chart === "undefined") return;' +
                    'try {' +
                        'const labels = ' + JSON.stringify(chartLabels) + ';' +
                        'const hist = ' + JSON.stringify(histogramValues) + ';' +
                        'const macdLine = ' + JSON.stringify(macdValues) + ';' +
                        'const sigLine = ' + JSON.stringify(signalValues) + ';' +
                        'const barColors = ' + JSON.stringify(barColors) + ';' +
                        'const yLimit = ' + JSON.stringify(yLimit) + ';' +

                        'new Chart(ctx, {' +
                            'data: {' +
                                'labels: labels,' +
                                'datasets: [' +
                                    '{ type: "bar", label: "Histogram", data: hist, backgroundColor: barColors, borderWidth: 0, barThickness: 8 },' +
                                    '{ type: "line", label: "MACD", data: macdLine, borderColor: "rgba(40,167,69,1)", backgroundColor: "rgba(40,167,69,0.05)", tension: 0.25, pointRadius: 0, borderWidth: 2 },' +
                                    '{ type: "line", label: "Signal", data: sigLine, borderColor: "rgba(255,193,7,1)", backgroundColor: "rgba(255,193,7,0.03)", tension: 0.25, pointRadius: 0, borderWidth: 2 }' +
                                ']' +
                            '},' +
                            'options: {' +
                                'responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } },' +
                                'scales: {' +
                                    'y: { min: -yLimit, max: yLimit, grid: { color: "rgba(0,0,0,0.06)" }, ticks: { color: "var(--text-secondary)" } },' +
                                    'x: { grid: { display: false }, ticks: { color: "var(--text-secondary)", maxRotation: 0 } }' +
                                '},' +
                                'interaction: { mode: "index", intersect: false },' +
                                'elements: { bar: { borderRadius: 2 } }' +
                            '}' +
                        '});' +
                    '} catch (e) { console.error(e); }' +
                '}, 80);' +
            '<\/script>';

            return html + initScript;
        }
        // Generate overall recommendation
        function generateOverallRecommendation(analyses) {
            const signals = [];
            
            if (analyses.rsi) {
                // RSI signal logic
                const rsiValues = [];
                Object.keys(analyses.rsi).forEach(key => {
                    if (key.toUpperCase().includes('RSI')) {
                        const rsiValue = parseFloat(analyses.rsi[key]);
                        if (!isNaN(rsiValue)) rsiValues.push(rsiValue);
                    }
                });
                
                const overboughtThreshold = parseInt(document.getElementById('rsiOverbought').value) || 70;
                const oversoldThreshold = parseInt(document.getElementById('rsiOversold').value) || 30;
                const overboughtCount = rsiValues.filter(v => v >= overboughtThreshold).length;
                const oversoldCount = rsiValues.filter(v => v <= oversoldThreshold).length;
                
                if (oversoldCount > overboughtCount) signals.push('BUY');
                else if (overboughtCount > oversoldCount) signals.push('SELL');
                else signals.push('HOLD');
            }
            
            if (analyses.ema) {
                // EMA signal logic
                const ema9 = parseFloat(analyses.ema['EMA9']);
                const ema15 = parseFloat(analyses.ema['EMA15']);
                if (!isNaN(ema9) && !isNaN(ema15)) {
                    if (ema9 > ema15) signals.push('BUY');
                    else signals.push('SELL');
                }
            }
            
            if (analyses.dma) {
                // DMA signal logic
                const cmp = parseFloat(analyses.dma['CMP']) || 0;
                let aboveCount = 0, belowCount = 0;
                Object.keys(analyses.dma).forEach(key => {
                    if (key.toUpperCase().includes('DMA')) {
                        const dmaValue = parseFloat(analyses.dma[key]);
                        if (!isNaN(dmaValue)) {
                            if (cmp > dmaValue) aboveCount++;
                            else belowCount++;
                        }
                    }
                });
                
                if (aboveCount > belowCount) signals.push('BUY');
                else if (belowCount > aboveCount) signals.push('SELL');
                else signals.push('HOLD');
            }
            
            // Overall consensus
            const buyCount = signals.filter(s => s === 'BUY').length;
            const sellCount = signals.filter(s => s === 'SELL').length;
            const holdCount = signals.filter(s => s === 'HOLD').length;
            
            let overallSignal = 'HOLD';
            let signalType = 'neutral';
            let consensus = 'Mixed';
            
            if (buyCount > sellCount && buyCount > holdCount) {
                overallSignal = 'BUY';
                signalType = 'bullish';
                consensus = buyCount === signals.length ? 'Strong' : 'Moderate';
            } else if (sellCount > buyCount && sellCount > holdCount) {
                overallSignal = 'SELL';
                signalType = 'bearish';
                consensus = sellCount === signals.length ? 'Strong' : 'Moderate';
            }

            const symbol = analyses.rsi?.['Symbol'] || analyses.ema?.['Symbol'] || analyses.dma?.['Symbol'] || analyses.macd?.['Symbol'] || 'N/A';
            
            return '<div class="summary-card" style="background: linear-gradient(135deg, ' + (signalType === 'bullish' ? 'rgba(40, 167, 69, 0.1)' : signalType === 'bearish' ? 'rgba(220, 53, 69, 0.1)' : 'rgba(108, 117, 125, 0.1)') + ' 0%, var(--bg-primary) 100%); border: 2px solid ' + (signalType === 'bullish' ? 'var(--success)' : signalType === 'bearish' ? 'var(--danger)' : '#6c757d') + '; margin-top: 1rem;">' +
                '<div style="text-align: center; padding: 1.5rem;">' +
                    '<h3 style="margin: 0 0 1rem 0; color: ' + (signalType === 'bullish' ? 'var(--success)' : signalType === 'bearish' ? 'var(--danger)' : '#6c757d') + ';">' +
                        '<i class="fas fa-' + (signalType === 'bullish' ? 'thumbs-up' : signalType === 'bearish' ? 'thumbs-down' : 'hand-paper') + '"></i>' +
                        'Final Recommendation: <strong>' + overallSignal + '</strong>' +
                    '</h3>' +

                    '<div style="font-size: 1.1rem; margin-bottom: 1rem;">' +
                        '<strong style="color: var(--text-primary);">' + consensus + ' Consensus</strong> ' +
                        '<span style="color: var(--text-secondary);">(' + buyCount + ' Buy, ' + sellCount + ' Sell, ' + holdCount + ' Hold)</span>' +
                    '</div>' +

                    '<div style="font-size: 1.3rem; font-weight: bold; color: ' + (signalType === 'bullish' ? 'var(--success)' : signalType === 'bearish' ? 'var(--danger)' : '#6c757d') + ';">' +
                        (overallSignal === 'BUY' ? '🎯 EXECUTE LONG POSITION' :
                          overallSignal === 'SELL' ? '🎯 EXECUTE SHORT POSITION' :
                          '🎯 WAIT FOR CONFIRMATION') +
                    '</div>' +

                    '<div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border-color); font-size: 0.9rem; color: var(--text-secondary);">' +
                        'Risk Management: Always use stop-loss and position sizing appropriate for your risk tolerance.' +
                    '</div>' +
                '</div>' +
            '</div>';
        }

        // Sort table by column (disabled for now)
        function sortTable(column) {
            // Sorting UI disabled - will work on this later
            console.log('Table sorting UI disabled - working on it later');
            return;
            
            // Only allow sorting for Time column
            if (column !== 'Time') {
                console.log('Sorting disabled for non-Time columns');
                return;
            }
            
            if (currentSortColumn === column) {
                // Toggle sort direction if same column
                currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                // New column, default to descending for Time
                currentSortColumn = column;
                currentSortDirection = 'desc';
            }

            // Update sort icons
            updateSortIcons();

            // Re-render table with new sort
            const output = scannerOutputs[currentScanner];
            if (output && output.trim()) {
                const tableData = parseScannerOutput(output);
                if (tableData && tableData.length > 0) {
                    renderTable(tableData);
                }
            }
        }

        // Update sort icons in headers (disabled for now)
        function updateSortIcons() {
            // Sort icons disabled for now - will work on sorting UI later
            // The default descending sort icon is shown in HTML
            console.log('Sort icons update disabled - will improve sorting UI later');
            return;
            
            // Reset all sort icons
            document.querySelectorAll('th span').forEach(icon => {
                icon.innerHTML = '';
            });

            // Set active sort icon (simplified)
            const activeHeader = document.getElementById(currentSortColumn.toLowerCase() + 'Header') || 
                               document.querySelector(`[onclick="sortTable('${currentSortColumn}')"]`);
            if (activeHeader) {
                const icon = activeHeader.querySelector('span');
                if (icon) {
                    icon.innerHTML = currentSortDirection === 'asc' ? ' ↑' : ' ↓';
                }
            }
        }

        // Update current date and time display
        function updateDateTime() {
            const now = new Date();
            const options = {
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: true
            };
            const dateTimeString = now.toLocaleDateString('en-US', options);
            document.getElementById('currentDateTime').textContent = dateTimeString;
        }

        // Generate horizontal final recommendation card (full width)
        function generateOverallRecommendationCardHorizontal(analyses) {
            const signals = [];
            
            if (analyses.rsi) {
                // RSI signal logic  
                const rsiValues = [];
                Object.keys(analyses.rsi).forEach(key => {
                    if (key.toUpperCase().includes('RSI')) {
                        const rsiValue = parseFloat(analyses.rsi[key]);
                        if (!isNaN(rsiValue)) rsiValues.push(rsiValue);
                    }
                });
                
                const overboughtThreshold = parseInt(document.getElementById('rsiOverbought').value) || 70;
                const oversoldThreshold = parseInt(document.getElementById('rsiOversold').value) || 30;
                const overboughtCount = rsiValues.filter(v => v >= overboughtThreshold).length;
                const oversoldCount = rsiValues.filter(v => v <= oversoldThreshold).length;
                
                if (oversoldCount > overboughtCount) signals.push('BUY');
                else if (overboughtCount > oversoldCount) signals.push('SELL');
                else signals.push('HOLD');
            }
            
            if (analyses.ema) {
                // EMA signal logic
                const ema9 = parseFloat(analyses.ema['EMA9']);
                const ema15 = parseFloat(analyses.ema['EMA15']);
                if (!isNaN(ema9) && !isNaN(ema15)) {
                    if (ema9 > ema15) signals.push('BUY');
                    else signals.push('SELL');
                }
            }
            
            if (analyses.dma) {
                // DMA signal logic
                const cmp = parseFloat(analyses.dma['CMP']) || 0;
                let aboveCount = 0, belowCount = 0;
                Object.keys(analyses.dma).forEach(key => {
                    if (key.toUpperCase().includes('DMA')) {
                        const dmaValue = parseFloat(analyses.dma[key]);
                        if (!isNaN(dmaValue)) {
                            if (cmp > dmaValue) aboveCount++;
                            else belowCount++;
                        }
                    }
                });
                
                if (aboveCount > belowCount) signals.push('BUY');
                else if (belowCount > aboveCount) signals.push('SELL');
                else signals.push('HOLD');
            }
            
            // Overall consensus
            const buyCount = signals.filter(s => s === 'BUY').length;
            const sellCount = signals.filter(s => s === 'SELL').length;
            const holdCount = signals.filter(s => s === 'HOLD').length;
            
            let overallSignal = 'HOLD';
            let signalType = 'neutral';
            let consensus = 'Mixed';
            
            if (buyCount > sellCount && buyCount > holdCount) {
                overallSignal = 'BUY';
                signalType = 'bullish';
                consensus = buyCount === signals.length ? 'Strong' : 'Moderate';
            } else if (sellCount > buyCount && sellCount > holdCount) {
                overallSignal = 'SELL';
                signalType = 'bearish';
                consensus = sellCount === signals.length ? 'Strong' : 'Moderate';
            }

            return '<div class="summary-card final-recommendation-horizontal" style="padding: 0.5rem;background: linear-gradient(135deg, ' + (signalType === 'bullish' ? 'rgba(40, 167, 69, 0.1)' : signalType === 'bearish' ? 'rgba(220, 53, 69, 0.1)' : 'rgba(108, 117, 125, 0.1)') + ' 0%, var(--bg-primary) 100%); border: 2px solid ' + (signalType === 'bullish' ? 'var(--success)' : signalType === 'bearish' ? 'var(--danger)' : '#6c757d') + ';">' +
                '<div class="final-recommendation-horizontal-content">' +
                    '<div class="recommendation-icon">' +
                        '<i class="fas fa-bullseye" style="color: ' + (signalType === 'bullish' ? 'var(--success)' : signalType === 'bearish' ? 'var(--danger)' : '#6c757d') + '; font-size: 2rem;"></i>' +
                    '</div>' +
                    '<div class="recommendation-main">' +
                        '<h3 style="margin: 0; color: var(--text-primary); font-size: 1.2rem;">' +
                            '<i class="fas fa-' + (signalType === 'bullish' ? 'thumbs-up' : signalType === 'bearish' ? 'thumbs-down' : 'hand-paper') + '" style="color: ' + (signalType === 'bullish' ? 'var(--success)' : signalType === 'bearish' ? 'var(--danger)' : '#6c757d') + '; margin-right: 0.5rem;"></i>' +
                            'Final Recommendation' +
                        '</h3>' +
                        '<div style="color: var(--text-secondary); font-size: 0.9rem;">' +
                            consensus + ' consensus from ' + signals.length + ' indicators' +
                        '</div>' +
                    '</div>' +
                    '<div class="recommendation-signal">' +
                        '<div style="font-size: 1.5rem; font-weight: bold; color: ' + (signalType === 'bullish' ? 'var(--success)' : signalType === 'bearish' ? 'var(--danger)' : '#6c757d') + ';">' +
                            overallSignal +
                        '</div>' +
                        '<div style="font-size: 0.8rem; color: var(--text-secondary); margin-top: 0.2rem;">' +
                            buyCount + 'B • ' + sellCount + 'S • ' + holdCount + 'H' +
                        '</div>' +
                    '</div>' +
                    '<div class="recommendation-action">' +
                        '<div style="font-weight: bold; color: ' + (signalType === 'bullish' ? 'var(--success)' : signalType === 'bearish' ? 'var(--danger)' : '#6c757d') + '; padding: 0.5rem 1rem; background: var(--bg-secondary); border-radius: 4px; text-align: center;">' +
                            (overallSignal === 'BUY' ? '🎯 EXECUTE LONG' :
                              overallSignal === 'SELL' ? '🎯 EXECUTE SHORT' :
                              '🎯 WAIT & WATCH') +
                        '</div>' +
                    '</div>' +
                '</div>' +
            '</div>';
        }

        // Generate Price Chart Card by copying Detail section structure
        function generatePriceChartCard(analyses) {
            const hasRSI = analyses.rsi && Object.keys(analyses.rsi).length > 0;
            const hasEMA = analyses.ema && Object.keys(analyses.ema).length > 0;
            const hasDMA = analyses.dma && Object.keys(analyses.dma).length > 0;
            
            return '<div class="analysis-card chart-card" style="border: 1px solid var(--border-color);">' +
                '<!-- Exact copy of Detail section chart content -->' +
                '<div class="mb-3" style="display: flex; justify-content: space-between; align-items: center; padding: 1rem 1rem 0.5rem 1rem;">' +
                    '<h4 style="margin: 0;"><i class="fas fa-chart-area"></i> Price Chart</h4>' +
                    '<div style="display: flex; align-items: center; gap: 0.5rem;">' +
                        '<label class="form-label" style="margin: 0;">Chart Type:</label>' +
                        '<select id="analysisChartTypeSelect" onchange="changeAnalysisChartType()" class="form-select" style="font-size: 0.85rem; padding: 0.25rem;">' +
                            '<option value="line">Line Chart</option>' +
                            '<option value="candlestick">Candlestick (Colored Points)</option>' +
                        '</select>' +
                        '<button id="analysisMacdPreviewBtn" class="btn btn-secondary" style="margin-left:8px;" onclick="macdPreview(\'analysis\')">Preview</button>' +
                    '</div>' +
                '</div>' +

                '<!-- Chart tabs -->' +
                '<div style="padding: 0 1rem; margin-bottom: 0.5rem;">' +
                    '<div class="chart-tabs">' +
                        '<button class="chart-tab ' + (hasRSI ? 'active' : 'disabled') + '" data-chart="rsi" onclick="switchAnalysisChartTab(\'rsi\')" ' + (!hasRSI ? 'disabled' : '') + '>RSI</button>' +
                        '<button class="chart-tab ' + (!hasRSI && hasEMA ? 'active' : hasEMA ? '' : 'disabled') + '" data-chart="ema" onclick="switchAnalysisChartTab(\'ema\')" ' + (!hasEMA ? 'disabled' : '') + '>EMA</button>' +
                        '<button class="chart-tab ' + (!hasRSI && !hasEMA && hasDMA ? 'active' : hasDMA ? '' : 'disabled') + '" data-chart="dma" onclick="switchAnalysisChartTab(\'dma\')" ' + (!hasDMA ? 'disabled' : '') + '>DMA</button>' +
                        '<button class="chart-tab ' + (!hasRSI && !hasEMA && !hasDMA && (analyses.macd && analyses.macd.length > 0) ? 'active' : (analyses.macd && analyses.macd.length > 0 ? '' : 'disabled')) + '" data-chart="macd" onclick="switchAnalysisChartTab(\'macd\')" ' + (!(analyses.macd && analyses.macd.length > 0) ? 'disabled' : '') + '>MACD</button>' +
                        '<button class="chart-tab ' + ((analyses.volume && analyses.volume.length>0) ? '' : 'disabled') + '" data-chart="volume" onclick="switchAnalysisChartTab(\'volume\')" ' + (!(analyses.volume && analyses.volume.length>0) ? 'disabled' : '') + '>VOLUME</button>' +
                    '</div>' +
                '</div>' +

                '<!-- Direct copy of chartContainer from Detail section -->' +
                '<div id="analysisChartContainer" style="padding: 0 1rem 1rem 1rem;">' +
                    '<div class="chart-container">' +
                        '<canvas id="analysisChart" width="400" height="250"></canvas>' +
                    '</div>' +
                    '<div style="margin-top: 0.5rem;">' +
                        '<canvas id="analysisVolumeChart" width="400" height="120" style="display:none;"></canvas>' +
                    '</div>' +
                '</div>' +
            '</div>';
        }

        // Switch chart tab functionality - simplified to use existing chart system
        function switchAnalysisChartTab(chartType) {
            console.log('Switching to analysis chart tab:', chartType);

            // Keep a reference to restore later
            const originalScanner = currentScanner;
            currentScanner = chartType;

            // Update tab UI
            document.querySelectorAll('.chart-tab').forEach(tab => tab.classList.remove('active'));
            const selectedTab = document.querySelector(`[data-chart="${chartType}"]`);
            if (selectedTab && selectedTab.disabled) {
                console.warn('Selected analysis tab is disabled:', chartType);
                currentScanner = originalScanner;
                return;
            }
            if (selectedTab) selectedTab.classList.add('active');

            // Prepare analysis canvas elements
            const analysisContainer = document.getElementById('analysisChartContainer');
            const analysisCanvas = document.getElementById('analysisChart');
            const analysisVolumeCanvas = document.getElementById('analysisVolumeChart');

            // If it's a volume tab, render using the volume helpers (bar chart)
            if (chartType === 'volume') {
                // Make sure we have chart data or try to build from outputs
                if ((!scannerChartData.volume || !Array.isArray(scannerChartData.volume.labels) || scannerChartData.volume.labels.length === 0) && scannerOutputs.volume) {
                    ensureVolumeChartDataAvailable();
                }

                if (scannerChartData.volume && Array.isArray(scannerChartData.volume.labels) && scannerChartData.volume.labels.length > 0) {
                    if (analysisContainer && analysisCanvas) {
                        // Temporarily swap ids so createVolumeBarChart uses the analysis canvas
                        analysisContainer.id = 'chartContainer';
                        analysisCanvas.id = 'priceChart';

                        try {
                            createVolumeBarChart(scannerChartData.volume);
                        } catch (err) {
                            console.warn('Failed to create analysis volume bar chart:', err);
                            showAnalysisNoChartData('volume');
                        }

                        // Restore ids
                        analysisContainer.id = 'analysisChartContainer';
                        analysisCanvas.id = 'analysisChart';
                    }

                    // Also render the small analysis volume chart and ensure it's visible
                    if (analysisVolumeCanvas) {
                        analysisVolumeCanvas.style.display = '';
                        try { renderVolumeAnalysisChart(scannerChartData.volume); } catch (e) { console.warn('renderVolumeAnalysisChart failed', e); }
                    }
                } else {
                    console.warn('No volume chart data available for analysis');
                    showAnalysisNoChartData('volume');
                    if (analysisVolumeCanvas) analysisVolumeCanvas.style.display = 'none';
                }

                // Restore scanner selection
                currentScanner = originalScanner;
                return;
            }

            // Non-volume charts: use existing chart creation flow
            if (scannerChartData[chartType]) {
                console.log('Creating chart using existing system for:', chartType);
                const chartTypeSelect = document.getElementById('analysisChartTypeSelect');
                const selectedChartType = chartTypeSelect ? chartTypeSelect.value : 'line';

                if (analysisContainer && analysisCanvas) {
                    // Temporarily repoint the main chart creation to analysis canvas
                    analysisContainer.id = 'chartContainer';
                    analysisCanvas.id = 'priceChart';

                    try {
                        createChart(scannerChartData[chartType], selectedChartType);
                    } catch (err) {
                        console.warn('Failed to create analysis chart for', chartType, err);
                        showAnalysisNoChartData(chartType);
                    }

                    // Restore IDs
                    analysisContainer.id = 'analysisChartContainer';
                    analysisCanvas.id = 'analysisChart';
                }
            } else {
                console.warn('No chart data available for:', chartType);
                showAnalysisNoChartData(chartType);
            }

            // Hide the small volume canvas when not on volume tab
            if (analysisVolumeCanvas) analysisVolumeCanvas.style.display = 'none';

            // Restore original scanner
            currentScanner = originalScanner;
        }
        
        // Change analysis chart type - simplified
        function changeAnalysisChartType() {
            const chartTypeSelect = document.getElementById('analysisChartTypeSelect');
            const activeTab = document.querySelector('.chart-tab.active');
            
            if (chartTypeSelect && activeTab) {
                const chartType = activeTab.getAttribute('data-chart');
                if (chartType && scannerChartData[chartType]) {
                    // Re-trigger the chart creation with new type
                    switchAnalysisChartTab(chartType);
                }
            }
        }
        
        // Show message when no chart data is available
        function showAnalysisNoChartData(chartType) {
            const chartContainer = document.getElementById('analysisChartContainer');
            if (chartContainer) {
                chartContainer.innerHTML = `
                    <div class="chart-container" style="height: 250px; display: flex; align-items: center; justify-content: center; color: var(--text-secondary);">
                        <div style="text-align: center;">
                            <i class="fas fa-chart-line" style="font-size: 3rem; margin-bottom: 1rem; display: block; color: var(--text-muted);"></i>
                            <div style="font-size: 1.1rem; margin-bottom: 0.5rem;">No ${chartType.toUpperCase()} Chart Data</div>
                            <div style="font-size: 0.8rem;">Run ${chartType.toUpperCase()} analysis to view chart</div>
                        </div>
                    </div>
                `;
            }
        }

        // Initial date and time setup
        updateDateTime();
        setInterval(updateDateTime, 1000); // Update every second
    </script>
</body>
</html>






